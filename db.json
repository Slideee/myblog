{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/images/cm.png","path":"images/cm.png","modified":0,"renderable":0},{"_id":"source/images/gfs.jpeg","path":"images/gfs.jpeg","modified":0,"renderable":0},{"_id":"source/images/img.png","path":"images/img.png","modified":0,"renderable":0},{"_id":"source/images/sh1.jpeg","path":"images/sh1.jpeg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/rating.js","path":"js/third-party/rating.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/matomo.js","path":"js/third-party/analytics/matomo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_data/footer.swig","hash":"6946f1fa832ea1cf96e8a3d191b4fd9e1ba033bc","modified":1665897019132},{"_id":"source/about/index.md","hash":"319269033cab431e1344c655ccdbe13465f2711f","modified":1665896216962},{"_id":"source/_posts/configmap.md","hash":"6bf774b17e73f01c2eeed94f2cd51d922fab8e1b","modified":1665894927637},{"_id":"source/_posts/broker_store.md","hash":"e3bf58fc3fc33721ed654dea8e8c3d1d860d4662","modified":1665894949813},{"_id":"source/categories/index.md","hash":"cdbfeb9679f03dd287ac359886204ab5b54ad078","modified":1665894887236},{"_id":"source/photos/index.md","hash":"7aef3308a541c8b7dae22ae55ad2e35a68156ac6","modified":1665895204431},{"_id":"source/tags/index.md","hash":"9b03c7e3351135a88978312bf7a3c1e10334ce63","modified":1665894816897},{"_id":"source/images/cm.png","hash":"b1e7458f607ef7bbf7f742af2914dd4a1cf067fc","modified":1665541427349},{"_id":"source/images/sh1.jpeg","hash":"d9ab7c47aaeef511871b335f0cc3cf3739627fc6","modified":1658375270546},{"_id":"source/images/img.png","hash":"2e969abae78b3f075cdcdf9dd7ee32e4b3f8fde5","modified":1665896301526},{"_id":"source/images/gfs.jpeg","hash":"41d5d3ca2e669eb6c5e7e182e43f0fc109e5ee39","modified":1665758378527},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1665892626191},{"_id":"themes/next/.gitignore","hash":"417520c4dbbeab9c7e3ab10d944da0886366a0ee","modified":1665892626192},{"_id":"themes/next/.eslintrc.json","hash":"9c0762486f24a8c5e60f8b6c875e4c4728942649","modified":1665892626191},{"_id":"themes/next/.gitattributes","hash":"ec43734985e1cafd53d88ded3020103f7416123c","modified":1665892626191},{"_id":"themes/next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1665892626192},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1665892626192},{"_id":"themes/next/_vendors.yml","hash":"618ea653d36f4444a0768513788a3f11beaddd16","modified":1665892626193},{"_id":"themes/next/package.json","hash":"4cdf28232ac2e9f5aca6aac62edb7569a5a2905b","modified":1665892626202},{"_id":"themes/next/_config.yml","hash":"9576131f24670dc4841a13b23fea1e8d2944d425","modified":1665901341453},{"_id":"themes/next/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1665892626202},{"_id":"themes/next/README.md","hash":"56638e4978154a2f2a3f03ba84047b77b4a499cc","modified":1665892626193},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1665892626193},{"_id":"themes/next/.githooks/install.js","hash":"4d77dbddf2eac1f3fc78f151d12ed22208ed655b","modified":1665892626191},{"_id":"themes/next/.githooks/pre-commit","hash":"f473eac1aaaa96c947d67988bbed140bbab1a821","modified":1665892626191},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"21cbff565a0445d3a880fff1ee417e309740a9ab","modified":1665892626191},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"330656d93b6c03df9fb1f2f0e3534c971969473b","modified":1665892626191},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"3e9fbb78e3dee0ca1dc886d0c28b0148ba0ca499","modified":1665892626192},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1665892626192},{"_id":"themes/next/.github/config.yml","hash":"7984e665e9de481a0e0e51fca5668337713f810b","modified":1665892626192},{"_id":"themes/next/.github/labeler.yml","hash":"5c4bc2bd561e6d9b33ee118cc12218c5de46f72d","modified":1665892626192},{"_id":"themes/next/.github/label-commenter-config.yml","hash":"1097fc47beeacfc1edb0248c27b17bf64bde3565","modified":1665892626192},{"_id":"themes/next/.github/release.yml","hash":"112310b81f959747f8eaafc2ca2150e1dcf916d8","modified":1665892626192},{"_id":"themes/next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1665892626193},{"_id":"themes/next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1665892626193},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1665892626193},{"_id":"themes/next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1665892626194},{"_id":"themes/next/languages/ar.yml","hash":"bca66db21c015dbd32970d8708b898518a773e1e","modified":1665892626194},{"_id":"themes/next/languages/bn.yml","hash":"fccbf2855392186e11daa8590121073594037b7b","modified":1665892626194},{"_id":"themes/next/languages/default.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":1665892626194},{"_id":"themes/next/languages/de.yml","hash":"4be7b8b76c81bf1853eb36d2e874b17546a0e792","modified":1665892626194},{"_id":"themes/next/languages/en.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":1665892626194},{"_id":"themes/next/languages/fa.yml","hash":"6456d40dd42f44101d9d6e7054e9884e9163f948","modified":1665892626194},{"_id":"themes/next/languages/id.yml","hash":"14e794db4eca36b257994d81eb513e61d1edcbd6","modified":1665892626194},{"_id":"themes/next/languages/it.yml","hash":"c1eeab4992c76bfd436bb205ce58b1cfeef55ee6","modified":1665892626195},{"_id":"themes/next/languages/es.yml","hash":"b813da5aed9d73b809133db4dfb08f90ec56afd9","modified":1665892626194},{"_id":"themes/next/languages/fr.yml","hash":"b15dc05afdc94de02e5d3fee4f8d3dc5594dd37e","modified":1665892626194},{"_id":"themes/next/languages/ko.yml","hash":"819c19eb9d142e5411f77cf3821d90f740ee114a","modified":1665892626195},{"_id":"themes/next/languages/ja.yml","hash":"d48c4157e0e02e847aac7b513580d3364c81948c","modified":1665892626195},{"_id":"themes/next/languages/nl.yml","hash":"ecb8e39c6225f3c068a5fdd569ee7dafd5c41a1f","modified":1665892626195},{"_id":"themes/next/languages/pt-BR.yml","hash":"a1f27b3a592fc58f17d247f5563ff4a90a3da5f2","modified":1665892626195},{"_id":"themes/next/languages/pt.yml","hash":"63a3e1e728ba5e6e22150de7331bb8a654f34960","modified":1665892626195},{"_id":"themes/next/languages/si.yml","hash":"615d18d044f44df476d6bfbf73f7b0edc2632168","modified":1665892626195},{"_id":"themes/next/languages/ru.yml","hash":"8c2b6361f2de17561c1a3eede2bf47b4e2ba6ce5","modified":1665892626195},{"_id":"themes/next/languages/tr.yml","hash":"0bebba73d6f06c7dad61f80c0d7ad5f6f1791a01","modified":1665892626195},{"_id":"themes/next/languages/uk.yml","hash":"7dd24580c0865c5a7bc4d391855045366a598936","modified":1665892626195},{"_id":"themes/next/languages/tk.yml","hash":"519239e35c3bda7b62b00ff5d34644f45b16fe6a","modified":1665892626195},{"_id":"themes/next/languages/vi.yml","hash":"c669c34da544a563ceae3e196addc9df6a78e024","modified":1665892626195},{"_id":"themes/next/languages/zh-HK.yml","hash":"f195bb0502ffe66e850077a1af1033455ea65f93","modified":1665892626196},{"_id":"themes/next/languages/zh-TW.yml","hash":"92256b90028de9a1e79c6bc0e5885b93e7fb4b17","modified":1665892626196},{"_id":"themes/next/layout/_layout.njk","hash":"20e4160cd0deb4fa272cc3aed0f43520b3cf4a9c","modified":1665892626196},{"_id":"themes/next/layout/index.njk","hash":"dd63e488ae8cc144335a5958acedf6a16edd7a92","modified":1665892626202},{"_id":"themes/next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1665892626202},{"_id":"themes/next/languages/zh-CN.yml","hash":"1742ecb9793596ca8926db9ff93ad18fdc6e8c76","modified":1665896690724},{"_id":"themes/next/layout/category.njk","hash":"c68b7343d0f8145010f93351908cc36ef6212ec1","modified":1665892626202},{"_id":"themes/next/layout/page.njk","hash":"6c40aa438c658eb7f0cd0f6a759f18b43e7e8f93","modified":1665892626202},{"_id":"themes/next/layout/tag.njk","hash":"9e16ba20c28a7f2c6bc75aa427f48122301a30aa","modified":1665892626202},{"_id":"themes/next/layout/post.njk","hash":"6abeb85fb3e4c382ed4bb6049b12a807e6226e67","modified":1665892626202},{"_id":"themes/next/.github/ISSUE_TEMPLATE/config.yml","hash":"c40ae7903b6cc99f94c9d45ac7ba8c2850bb1309","modified":1665892626191},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"4ecac91716eac59d7c2bc53cf6e95612d44da97b","modified":1665892626192},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"fc4dce84ed9a5d21d3a8833ff6d776c46f876115","modified":1665892626191},{"_id":"themes/next/test/index.js","hash":"6bf0289846538be3e9a63809af98f00e1fbdd90b","modified":1665892626218},{"_id":"themes/next/.github/workflows/labeler.yml","hash":"e9d51e93f239a2d4b69722c69db3463b4baf0f4c","modified":1665892626192},{"_id":"themes/next/.github/workflows/linter.yml","hash":"2ab8720e4b9534e48ba324b73b0b58cb54df689f","modified":1665892626192},{"_id":"themes/next/.github/workflows/label-commenter.yml","hash":"434cc0674290958b1e9bbc46c3486f073c0722db","modified":1665892626192},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"8cc5b5c116f6a052865a324512362f145d699202","modified":1665892626192},{"_id":"themes/next/.github/workflows/tester.yml","hash":"80a20c3a7522249f051a48239db41d1317e9b552","modified":1665892626192},{"_id":"themes/next/docs/zh-CN/README.md","hash":"ccf27b9249524b9fec1c15497b4353c8d1748c6c","modified":1665892626194},{"_id":"themes/next/docs/ru/README.md","hash":"6c82bfd2ec8248c248da701f091b548a7a133580","modified":1665892626193},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7a06d443f374bd1e84294067a0ac796afd9fbe60","modified":1665892626193},{"_id":"themes/next/.github/workflows/lock.yml","hash":"e48d1ced9a673d3f0911a700d3e68c0f4ca79263","modified":1665892626192},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1665892626196},{"_id":"themes/next/layout/_macro/post.njk","hash":"434b3e76a040a816169e1929657e4176e7b8164c","modified":1665892626196},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"a089f7a8368ab0b7d7b9b7ec0ac3767a453435df","modified":1665892626194},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"9ed086e52f32851cc1d41640350cbdc89c3ba425","modified":1665897662544},{"_id":"themes/next/layout/_partials/comments.njk","hash":"d0c470b0f6690aa217e9ada848c5e2e73fb27c6f","modified":1665892626196},{"_id":"themes/next/layout/_partials/footer.njk","hash":"19713f472972caac33ae5fbcfe9105da61257de4","modified":1665892626196},{"_id":"themes/next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1665892626197},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1665892626197},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"852a750524decf1efa587cd52b09e387ed8315de","modified":1665892626199},{"_id":"themes/next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":1665892626201},{"_id":"themes/next/layout/_third-party/index.njk","hash":"d41eeb262978e34de4679d8971a9e7ac5d90ecbc","modified":1665892626201},{"_id":"themes/next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":1665892626201},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1665892626201},{"_id":"themes/next/layout/_third-party/rating.njk","hash":"1bcdbc7fde26d6d9ef4e7fa43ffcff5a9506b20e","modified":1665892626201},{"_id":"themes/next/scripts/events/index.js","hash":"3ce10d4cce94e3d4c482c2e18bb6f0f0ca380d3d","modified":1665892626202},{"_id":"themes/next/scripts/filters/locals.js","hash":"9eb5310664759931287dd28ea39165dfb67f12ed","modified":1665892626204},{"_id":"themes/next/layout/_scripts/index.njk","hash":"6668878a0f9a1166c6a879755f54a08d942da870","modified":1665892626199},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1665892626203},{"_id":"themes/next/scripts/filters/minify.js","hash":"f160e39943e39d7276da86adb47c3f08e5f22c7a","modified":1665892626204},{"_id":"themes/next/scripts/filters/post.js","hash":"30e03a1d4828259f82d46e64cbfe2955b6cff9a9","modified":1665892626204},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":1665892626199},{"_id":"themes/next/scripts/helpers/engine.js","hash":"d292b78485e8e8055712b0ed6de7cf559c5fbdcd","modified":1665892626204},{"_id":"themes/next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1665892626204},{"_id":"themes/next/scripts/helpers/navigation.js","hash":"78107021101553c3d23e89290f7530b60cf4aa86","modified":1665892626204},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"226fccbe9c93265e65a300e3cb4bf6f9065cfdd7","modified":1665892626204},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"a11b71ba0c5012e2cdcab31c15439156b215563e","modified":1665892626204},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":1665892626204},{"_id":"themes/next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1665892626204},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1665892626204},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1665892626204},{"_id":"themes/next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1665892626204},{"_id":"themes/next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1665892626205},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1665892626205},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":1665892626205},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"9ed799c329abf830f623689d7e136991256a24ca","modified":1665892626204},{"_id":"themes/next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1665892626205},{"_id":"themes/next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1665892626205},{"_id":"themes/next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1665892626205},{"_id":"themes/next/source/css/_colors.styl","hash":"3c6798c10cc220d83481cb3f3782e78558cee789","modified":1665892626205},{"_id":"themes/next/source/css/_mixins.styl","hash":"32d31cb5a155681c19f5ad0bb56dcb08429f93ef","modified":1665892626211},{"_id":"themes/next/source/css/main.styl","hash":"78ce791cc4ac95386cf6839ca72f5f7b51f86ee9","modified":1665892626213},{"_id":"themes/next/source/css/noscript.styl","hash":"263eddabfae40e54c0591e7baa8403ade8cdd56d","modified":1665892626213},{"_id":"themes/next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1665892626205},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1665892626213},{"_id":"themes/next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1665892626214},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1665892626214},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1665892626214},{"_id":"themes/next/source/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1665892626215},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1665892626214},{"_id":"themes/next/test/helpers/font.js","hash":"342ef3c6fd2dcca2a8802a516ed6d7f389fd2ca2","modified":1665892626218},{"_id":"themes/next/test/helpers/next-url.js","hash":"a91d880cb75e0a8e65a7be4c7362b2c8ebfb7c4f","modified":1665892626218},{"_id":"themes/next/test/helpers/index.js","hash":"63ba28afed697f7b3574436b1133b8ecc9c0c357","modified":1665892626218},{"_id":"themes/next/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1665892626215},{"_id":"themes/next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1665892626215},{"_id":"themes/next/source/js/motion.js","hash":"f7c825cbff11885fa0dffa64824fd00e505d6a8d","modified":1665892626216},{"_id":"themes/next/source/js/pjax.js","hash":"919f5281c4a04d11cfd94573ecf57b3dbabd3cc8","modified":1665892626216},{"_id":"themes/next/source/js/next-boot.js","hash":"da0f07f9eaaa83de70128b0feaea3fdadb90457a","modified":1665892626216},{"_id":"themes/next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1665892626215},{"_id":"themes/next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1665892626216},{"_id":"themes/next/source/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1665892626216},{"_id":"themes/next/source/js/utils.js","hash":"200088bfd042f5304b2a04befab0829148845e0e","modified":1665892626218},{"_id":"themes/next/test/tags/button.js","hash":"48f2aa4c513e9e24bd6a811410520b74cd7ea88b","modified":1665892626218},{"_id":"themes/next/test/tags/caniuse.js","hash":"aa5e728445caeaf7c2ccd0f3fcb2cad0c93ca6d1","modified":1665892626219},{"_id":"themes/next/test/tags/center-quote.js","hash":"7667342fd1a1417eaf6a254012b84ae40e8d13dd","modified":1665892626219},{"_id":"themes/next/test/tags/index.js","hash":"e8779e54f0979b221858f8bb74dd081bb503b910","modified":1665892626219},{"_id":"themes/next/test/tags/label.js","hash":"4ebf3698c258ca978b997acbdd0dece44069c09d","modified":1665892626219},{"_id":"themes/next/test/tags/group-pictures.js","hash":"5c68ae0184f9da6e00ba199f2554d503d8e6da71","modified":1665892626219},{"_id":"themes/next/test/tags/link-grid.js","hash":"43d298fafb7c45a874b766d443843bd26346e689","modified":1665892626219},{"_id":"themes/next/test/tags/note.js","hash":"3dcfcd65bf9f326972ea7571fdb1444200f5d07e","modified":1665892626219},{"_id":"themes/next/test/tags/pdf.js","hash":"fd6ea5123560a90f7e7c1eface23dbe1455db25f","modified":1665892626219},{"_id":"themes/next/test/tags/mermaid.js","hash":"ab77be5f3c6d9a57c7b9dda6decf1906a736fef9","modified":1665892626219},{"_id":"themes/next/test/tags/tabs.js","hash":"d63722919f9da2e44d6b952801e10a2915ea9c12","modified":1665892626219},{"_id":"themes/next/test/tags/video.js","hash":"b796fc4dceb20a30e730c322bb5474c0162464cc","modified":1665892626219},{"_id":"themes/next/test/validate/index.js","hash":"5a95ccc8598667535bd022e988055c0e019f3670","modified":1665892626219},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"8da52a144060db1a0a088ccb2e6cc8376d1fce70","modified":1665892626196},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"0ba2bf0266f1fcb8edbd961869f8521b29685c56","modified":1665892626196},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"aff4613756456be26415febc668860fdab8d33c5","modified":1665892626196},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"650de421a8ce4cf685428ffbe0087ff84cbd1356","modified":1665892626197},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"41a8b0cc16f60fa085cb719d07216d86b6bc4bf8","modified":1665892626197},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"ee6fc2f111572d3eeab0a2fecbb2d6b3e37ab26b","modified":1665892626197},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"06480d8ec5f0b87eafd47f082f07968d7282dd5c","modified":1665892626197},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"89825e75cc45e9709fa6ba89883669eedaff6f46","modified":1665892626197},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1665892626197},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1665892626197},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"0f4bc8e257da60f77c0c1738607b2bde55810684","modified":1665892626197},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1665892626197},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1665892626198},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1665892626199},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":1665892626199},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1665892626197},{"_id":"themes/next/layout/_partials/post/post-footer.njk","hash":"bde2c7356d9362972bde41cc206d5816f8ed714d","modified":1665892626197},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"9fa47e4fb342811da590ee4adc91cf81118c0a39","modified":1665892626197},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"c1e33b4889f75acc490af3c8bde0ec56c518ff41","modified":1665892626197},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"57eca76cfbbe9a65bc2a77f1deebf003ed335673","modified":1665892626198},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"002b51d0cae3f2e2e008bdc58be90c728282de5b","modified":1665892626198},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1665892626200},{"_id":"themes/next/layout/_third-party/analytics/cloudflare.njk","hash":"a5b8297c2c383124dd6a56e256ecc0c0dcf489be","modified":1665892626200},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1665892626200},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1665892626200},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"314805f0186e9f6208c845f0757fdb7891c540f6","modified":1665892626200},{"_id":"themes/next/layout/_third-party/analytics/matomo.njk","hash":"4e89648a8ec8194c5823064cbca39c938a799006","modified":1665892626200},{"_id":"themes/next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"9dc00fcb0a05899f048eace9f9160b78956655d5","modified":1665892626200},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1665892626200},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1665892626200},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1665892626200},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1665892626200},{"_id":"themes/next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1665892626200},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1665892626200},{"_id":"themes/next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1665892626200},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1665892626200},{"_id":"themes/next/layout/_third-party/chat/gitter.njk","hash":"f8cc14b7aa949999a1faaeb7855e2f20b59a386d","modified":1665892626200},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1665892626200},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1665892626201},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"1ebf658690468ea197bdd0416eb7cfa4bd0b083a","modified":1665892626201},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1665892626201},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":1665892626201},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":1665892626201},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1665892626201},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1665892626201},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1665892626201},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1665892626201},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1665892626202},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1665892626202},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"3d8591bb92df77ceb9d5b07bc76da1ca89e5bd76","modified":1665892626199},{"_id":"themes/next/scripts/events/lib/config.js","hash":"c8b59b404f5d2a0b3b5cd1a6c9a10af5f30e43b5","modified":1665892626202},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1665892626202},{"_id":"themes/next/scripts/events/lib/navigation.js","hash":"dd3562686d95a50375e6fd32e717ccb0d99c1e3d","modified":1665892626203},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1665892626202},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"ec996d0673f766167c86df0966e9da1ae036e103","modified":1665892626203},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"64e4024376b51fe81be7ad80235abdf0a83853bd","modified":1665892626203},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"5798cfc8f63665031dd3e01debed051628cec319","modified":1665892626203},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"19a402a225c31edffc50f202a14e0d582d3db23e","modified":1665892626203},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1665892626203},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1665892626203},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"62faf6b0b0020066a0dec1f0123cf1fee3198e7e","modified":1665892626203},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1665892626203},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1665892626203},{"_id":"themes/next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1665892626203},{"_id":"themes/next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1665892626203},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1665892626213},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e1fbf169b9b6a194b518240cbd06ec3c48b83d61","modified":1665892626213},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1665892626213},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c65536a128b9bc9dbe2fbb1b235a3cded2891002","modified":1665892626213},{"_id":"themes/next/source/css/_variables/base.styl","hash":"ea7b1818b282196c92e4fbb131c6249b46ca33d2","modified":1665892626213},{"_id":"themes/next/source/js/schemes/muse.js","hash":"9794bd4fc6a458322949d6a0ade89cd1026bc69f","modified":1665892626216},{"_id":"themes/next/source/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1665892626217},{"_id":"themes/next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1665892626217},{"_id":"themes/next/source/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1665892626217},{"_id":"themes/next/source/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1665892626217},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"bab653bcf226311381e8411a0492202f1bf1fce9","modified":1665892626205},{"_id":"themes/next/source/css/_common/components/index.styl","hash":"fe1868f47681e00a33a96199302be85377282f63","modified":1665892626205},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":1665892626208},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"d0a7c99095f490b0d2ed6b1be43d435960798cec","modified":1665892626210},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1665892626210},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1665892626210},{"_id":"themes/next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1665892626210},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1665892626210},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b5c7782368889fa9fd93807d28ff2daf270e3703","modified":1665892626210},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1665892626210},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"fd49b521d67eaccc629f77b4e095cb7310327565","modified":1665892626211},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":1665892626211},{"_id":"themes/next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":1665892626209},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"64775c729512b30b144ab5ae9dc4a4dfd4e13f35","modified":1665892626209},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":1665892626212},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":1665892626212},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"b7f48be3c43bfa393d62142544a5487a67871713","modified":1665892626212},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"944364893bd7160d954c10ba931af641c91515a4","modified":1665892626212},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1665892626212},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1665892626212},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"b741ab96e73370711c63a6581159f2ea8b5bfa1b","modified":1665892626212},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":1665892626212},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"72dc825c50357402c342d62ab60fc0c478ab6bc1","modified":1665892626212},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d9141e6e14a56b5952488101e9a8388c2170e270","modified":1665892626213},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1665892626213},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1665892626213},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1665892626216},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1665892626216},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1665892626216},{"_id":"themes/next/source/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1665892626216},{"_id":"themes/next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1665892626216},{"_id":"themes/next/source/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1665892626216},{"_id":"themes/next/source/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1665892626216},{"_id":"themes/next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1665892626216},{"_id":"themes/next/source/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1665892626217},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","hash":"33a82207a15aad9d1c8fb2251f9e3eba50452932","modified":1665892626217},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1665892626217},{"_id":"themes/next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1665892626217},{"_id":"themes/next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1665892626217},{"_id":"themes/next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1665892626217},{"_id":"themes/next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1665892626217},{"_id":"themes/next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1665892626217},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1665892626217},{"_id":"themes/next/source/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1665892626217},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","hash":"411a72df581f5b21317dc28633c7993207eb9e1c","modified":1665892626218},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":1665892626218},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"4817e77577896ab5c0da434549917ee703a3f4cf","modified":1665892626211},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":1665892626212},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"be6cf377ae8f4a01ee76f9b3014e74161d4d5d17","modified":1665892626212},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"fb550935d374e0bdf1097fce187337dc05cad3e1","modified":1665892626212},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1665892626212},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1665892626218},{"_id":"themes/next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1665892626218},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1665892626205},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1665892626206},{"_id":"themes/next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1665892626206},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1665892626206},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1665892626206},{"_id":"themes/next/source/css/_common/components/post/index.styl","hash":"d0805a763176b3c0003967401644f41dfe3bc9e8","modified":1665892626206},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":1665892626206},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"c81cb8793b207ac935244e1436d4d38efd1ac15b","modified":1665892626206},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"d757768a58743601d0d84158ba955eb15d4c3c01","modified":1665892626206},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"1d284f3ea03ba9b4feb76b375e539a8e0bccf1c3","modified":1665892626207},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1665892626207},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"010c901e4ef49a606f8a350efbf09044e76d2ff3","modified":1665892626207},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1665892626207},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"04cf4a69537fc14d3b8904f965d283356853847f","modified":1665892626207},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b6677dc2a2368084ab82bb4f145ac79e5966c150","modified":1665892626208},{"_id":"themes/next/source/css/_common/components/third-party/disqusjs.styl","hash":"c2326ee3e8b724d99c24a818ddee32813ea5bf89","modified":1665892626208},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"070737d101e7cd58e997e8c7af09958268c43a21","modified":1665892626208},{"_id":"themes/next/source/css/_common/components/third-party/gitter.styl","hash":"35104dc6883a61c31e0e368dac8ac2f697be62fe","modified":1665892626208},{"_id":"themes/next/source/css/_common/components/third-party/index.styl","hash":"979486a41a81f2a9fd8b0b87c4f87d6416c68c7d","modified":1665892626208},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":1665892626208},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"41ed817e1eb64078074e245e771446ee041e5790","modified":1665892626208},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"e72799ce3f9b79753e365b2f8c8ef6c310668d4a","modified":1665892626208},{"_id":"themes/next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":1665892626208},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"670fc109b56a010b166b86b616823a1aae97a738","modified":1665892626210},{"_id":"themes/next/source/css/_common/scaffolding/highlight/index.styl","hash":"f2328caa94645836e06fb39a6a9c9a84ed68a8b5","modified":1665892626210},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":1665892626210},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1665892626211},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1665892626210},{"_id":"themes/next/source/css/_common/scaffolding/tags/index.styl","hash":"3f76c73a891bbc10679753e702feba9e8a5ffdd2","modified":1665892626211},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":1665892626211},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7f8a7345e6537a62cd9e9a94c8f7065b541d9b04","modified":1665892626211},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":1665892626211},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"d27fbf7799695295dd5860a161a13ac4d90c5ba4","modified":1665892626211},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":1665892626208},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"7a39bcce7274284e87388743db62afc847fe6897","modified":1665892626211},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":1665892626208},{"_id":"themes/next/source/css/_common/outline/footer/index.styl","hash":"8b9407e5cfd0571ef8de7df19022b268f962fa2f","modified":1665892626208},{"_id":"themes/next/source/css/_common/outline/header/index.styl","hash":"ff642130354a0b3be0d708c43044ed4d710b5e83","modified":1665892626208},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"759e582d34d08e3386c55d87a835a9523608619f","modified":1665892626209},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1665892626209},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"392fd53a8dd4e3f33a853ebb24290a622300e0ff","modified":1665892626208},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1665892626209},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"b926e368f702f8686aaa2eb98d3d2e533418958c","modified":1665892626209},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"9950c3188a28e1c63b5498b7bdcd14b12ace3e28","modified":1665892626209},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":1665892626209},{"_id":"themes/next/source/css/_common/outline/sidebar/index.styl","hash":"cee43480eba028c37d51cb620c2d81486aa24e01","modified":1665892626209},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"fbdb63c6a8887d19b7137325ba7d6806f728139c","modified":1665892626209},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"ee94a1a27090ad24e3ed579093088d97ff96d77d","modified":1665892626209},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"3103b81fc76b59e1e2c161e2c484625c770ed66f","modified":1665892626209},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":1665892626209},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"021a37cf178440cc341940a299d3bca359996c6b","modified":1665892626209}],"Category":[{"name":"RocketMQ","_id":"cl9axa88k0004m1rge5tc4veb"},{"name":"Kubernetes","_id":"cl9axa88l0008m1rg83g14kkx"}],"Data":[{"_id":"footer","data":"<script color=\"0,0,255\" opacity=\"0.5\" zIndex=\"-1\" count=\"99\" src=\"https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js\"></script>\n"}],"Page":[{"title":"关于我","date":"2022-10-15T19:48:17.000Z","_content":"\n## Hey，我是Slide\n\n- 🐷 猪厂服务端开发工程师，94年，主攻云原生消息队列。\n- 👨‍💻 经历：早年写过业务，后来改写中间件了。日常开发语言为Java、Go、Erlang。\n- 🤔 爱好：猪厂食堂品鉴 | 永劫无间噩梦人机单三 | 健身房散步。\n- 👭 开源：目前为Apache RocketMQ社区贡献代码。\n- 💡 博客：主要用来记录一些日常生活，以及一些工作中的思考。\n- 😺 GitHub：[Slideee](https://github.com/Slideee)  一起交流学习。\n- 💬 微信：HUMBLEz94 欢迎找我内推哈。\n---","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2022-10-16 03:48:17\n---\n\n## Hey，我是Slide\n\n- 🐷 猪厂服务端开发工程师，94年，主攻云原生消息队列。\n- 👨‍💻 经历：早年写过业务，后来改写中间件了。日常开发语言为Java、Go、Erlang。\n- 🤔 爱好：猪厂食堂品鉴 | 永劫无间噩梦人机单三 | 健身房散步。\n- 👭 开源：目前为Apache RocketMQ社区贡献代码。\n- 💡 博客：主要用来记录一些日常生活，以及一些工作中的思考。\n- 😺 GitHub：[Slideee](https://github.com/Slideee)  一起交流学习。\n- 💬 微信：HUMBLEz94 欢迎找我内推哈。\n---","updated":"2022-10-16T04:56:56.962Z","path":"about/index.html","comments":1,"layout":"page","_id":"cl9axa88e0000m1rgcb5j9ls2","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"Hey，我是Slide\"><a href=\"#Hey，我是Slide\" class=\"headerlink\" title=\"Hey，我是Slide\"></a>Hey，我是Slide</h2><ul>\n<li>🐷 猪厂服务端开发工程师，94年，主攻云原生消息队列。</li>\n<li>👨‍💻 经历：早年写过业务，后来改写中间件了。日常开发语言为Java、Go、Erlang。</li>\n<li>🤔 爱好：猪厂食堂品鉴 | 永劫无间噩梦人机单三 | 健身房散步。</li>\n<li>👭 开源：目前为Apache RocketMQ社区贡献代码。</li>\n<li>💡 博客：主要用来记录一些日常生活，以及一些工作中的思考。</li>\n<li>😺 GitHub：<a href=\"https://github.com/Slideee\">Slideee</a>  一起交流学习。</li>\n<li>💬 微信：HUMBLEz94 欢迎找我内推哈。</li>\n</ul>\n<hr>\n","site":{"data":{"footer":"<script color=\"0,0,255\" opacity=\"0.5\" zIndex=\"-1\" count=\"99\" src=\"https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js\"></script>\n"}},"length":216,"excerpt":"","more":"<h2 id=\"Hey，我是Slide\"><a href=\"#Hey，我是Slide\" class=\"headerlink\" title=\"Hey，我是Slide\"></a>Hey，我是Slide</h2><ul>\n<li>🐷 猪厂服务端开发工程师，94年，主攻云原生消息队列。</li>\n<li>👨‍💻 经历：早年写过业务，后来改写中间件了。日常开发语言为Java、Go、Erlang。</li>\n<li>🤔 爱好：猪厂食堂品鉴 | 永劫无间噩梦人机单三 | 健身房散步。</li>\n<li>👭 开源：目前为Apache RocketMQ社区贡献代码。</li>\n<li>💡 博客：主要用来记录一些日常生活，以及一些工作中的思考。</li>\n<li>😺 GitHub：<a href=\"https://github.com/Slideee\">Slideee</a>  一起交流学习。</li>\n<li>💬 微信：HUMBLEz94 欢迎找我内推哈。</li>\n</ul>\n<hr>\n"},{"title":"分类","date":"2022-10-16T04:34:13.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2022-10-16 12:34:13\ntype: \"categories\"\n---\n","updated":"2022-10-16T04:34:47.236Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cl9axa88i0002m1rght23514o","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{"footer":"<script color=\"0,0,255\" opacity=\"0.5\" zIndex=\"-1\" count=\"99\" src=\"https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js\"></script>\n"}},"length":0,"excerpt":"","more":""},{"title":"照片","date":"2022-10-15T19:47:57.000Z","_content":"\n2022/10/14 22:49\n\n疫情回不了杭州，但还是要把6.824刷完的。\n\n \n![gfs](/images/gfs.jpeg)\n\n---\n2022-07 出差在上海。\n\n![sh1](/images/sh1.jpeg)\n","source":"photos/index.md","raw":"---\ntitle: 照片\ndate: 2022-10-16 03:47:57\n---\n\n2022/10/14 22:49\n\n疫情回不了杭州，但还是要把6.824刷完的。\n\n \n![gfs](/images/gfs.jpeg)\n\n---\n2022-07 出差在上海。\n\n![sh1](/images/sh1.jpeg)\n","updated":"2022-10-16T04:40:04.431Z","path":"photos/index.html","comments":1,"layout":"page","_id":"cl9axa88l0006m1rg5xy08h4c","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>2022&#x2F;10&#x2F;14 22:49</p>\n<p>疫情回不了杭州，但还是要把6.824刷完的。</p>\n<p><img src=\"/images/gfs.jpeg\" alt=\"gfs\"></p>\n<hr>\n<p>2022-07 出差在上海。</p>\n<p><img src=\"/images/sh1.jpeg\" alt=\"sh1\"></p>\n","site":{"data":{"footer":"<script color=\"0,0,255\" opacity=\"0.5\" zIndex=\"-1\" count=\"99\" src=\"https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js\"></script>\n"}},"length":60,"excerpt":"","more":"<p>2022&#x2F;10&#x2F;14 22:49</p>\n<p>疫情回不了杭州，但还是要把6.824刷完的。</p>\n<p><img src=\"/images/gfs.jpeg\" alt=\"gfs\"></p>\n<hr>\n<p>2022-07 出差在上海。</p>\n<p><img src=\"/images/sh1.jpeg\" alt=\"sh1\"></p>\n"},{"title":"标签","date":"2022-10-16T04:33:17.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2022-10-16 12:33:17\ntype: \"tags\"\n---\n","updated":"2022-10-16T04:33:36.897Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cl9axa88l0007m1rghmzj4wnb","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{"footer":"<script color=\"0,0,255\" opacity=\"0.5\" zIndex=\"-1\" count=\"99\" src=\"https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js\"></script>\n"}},"length":0,"excerpt":"","more":""}],"Post":[{"title":"RocketMQ存储机制详解","date":"2022-10-09T16:00:00.000Z","description":"CommitLog, ConsumeQueue, IndexFile源码解析.","author":"Slide","_content":"\n## CommitLog\n\n主要存储文件以及目录包含以下几个\n\n1. **abort** 用来记录整个broker是否为安全关闭的一个状态标识 在运行起来的时候会创建abort文件 安全关闭的情况下会删除 abort文件\n2. **checkpoint** 记录 commitlog，consumequeue, index 文件最后刷盘时间戳\n3. **commitlog**  存储所有消息的一个文件夹 该文件夹下包含当前broker接受的所有消息 下面会详细介绍commitlog存储消息的格式\n4. **config**  broker运行的一些配置文件 以及consumer的消费进度等\n5. **consumequeue**  topic对应消费队列的存储 每一个topic下面为每一个queue创建了一个目录目录名称为queue的id 下面会详细描述consumequeue的结构和作用\n6. **index** 消息索引 存储的是带有key的Message 下面为详细描述Index文件的作用以及结构\n7. **lock** 运行期间用到的全局锁\n\n\n\n\n\n### 写入方式\n\n在`MessageStore`的接口定义了几种PutMessage的方式\n\n```java\n// 异步写入返回CompletableFuture\ndefault CompletableFuture<PutMessageResult> asyncPutMessage(final MessageExtBrokerInner msg) {\n    return CompletableFuture.completedFuture(putMessage(msg));\n}\n\n// 异步批量写入 返回CompletableFuture\ndefault CompletableFuture<PutMessageResult> asyncPutMessages(final MessageExtBatch messageExtBatch) {\n    return CompletableFuture.completedFuture(putMessages(messageExtBatch));\n}\n\n// 同步写入直接返回PutMessageResult\nPutMessageResult putMessage(final MessageExtBrokerInner msg);\n\n//同步批量写入PutMessageResult\nPutMessageResult putMessages(final MessageExtBatch messageExtBatch);\n\n```\n\n\n\n### 数据格式\n\ncommitlog目录下存储的就是对应具体消息，commitlog文件名称是由20个十进制的数字组成的 表示当前commitlog文件起始的文件偏移量 第一个文件肯定是`00000000000000000000`，每一个commitlog文件大小都是固定的1G，但是对应的内容是**小余等于1G**，消息为一个整体单元不可分割所以是小余等于1G的。\n\n| **属性**                  | **描述**                                                 | 类型       |\n| ------------------------- | -------------------------------------------------------- | ---------- |\n| msgLen                    | 消息长度                                                 | Int        |\n| bodyCrc                   | checksum 校验                                            | Int        |\n| queueId                   | 队列id                                                   | Long       |\n| flag                      | 用户自定义                                               | Int        |\n| queueOffset               | 队列偏移量                                               | Long       |\n| physicalOffset            | 磁盘文件偏移量                                           | Long       |\n| sysFlag                   | 用来计算FilterType和事务状态                             | Int        |\n| bornHostTimestamp         | 消息创建时间                                             | Long       |\n| bornHost                  | 生产者Host, ipv4: IP(4)+Port(4) 8 , Ipv6: IP(16)+Port(4) | 8 or 20    |\n| storeTimeStamp            | 消息存储时间                                             | Long       |\n| storehostAddressLength    | broker地址                                               | 8 or 20    |\n| reconsumeTimes            | 回收时间                                                 | Int        |\n| preparedTransactionOffset | 预处理事务消息的偏移量                                   | Int        |\n| bodyLength                | 消息体长度                                               | Int        |\n| body                      | 消息体                                                   | bodyLength |\n| topicLength               | 消息归属Topic                                            |            |\n| propertiesLength          | 配置信息                                                 |            |\n\n\n\n### 写入机制\n\n#### 发送消息请求\n\n```java\n// 解析消息头 包含消息生产者发送的一些信息以及topic和队列信息\nSendMessageRequestHeader requestHeader = parseRequestHeader(request);\nif (requestHeader == null) {\n    return CompletableFuture.completedFuture(null);\n}\n// 消息的上下文 可以用于跟踪消息trace 基本上就是reqeustHeader中的一些信息\nmqtraceContext = buildMsgContext(ctx, requestHeader);\n//注册的一些消息hook\nthis.executeSendMessageHookBefore(ctx, request, mqtraceContext);\nif (requestHeader.isBatch()) {\n    //批量消息\n    return this.asyncSendBatchMessage(ctx, request, mqtraceContext, requestHeader);\n} else {\n    //单条消息\n    return this.asyncSendMessage(ctx, request, mqtraceContext, requestHeader);\n}\n\n```\n\n```java\nprivate CompletableFuture<RemotingCommand> asyncSendMessage(ChannelHandlerContext ctx, RemotingCommand request,\n                                                            SendMessageContext mqtraceContext,\n                                                            SendMessageRequestHeader requestHeader) {\n  \n  \n \n   int queueIdInt = requestHeader.getQueueId();\n   //获取topic的配置信息\n   TopicConfig topicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n    ....\n    MessageExtBrokerInner msgInner = new MessageExtBrokerInner();\n    ... //省去填充Message数据部分\n\n    CompletableFuture<PutMessageResult> putMessageResult = null;\n    String transFlag = origProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);\n    if (transFlag != null && Boolean.parseBoolean(transFlag)) {\n        //事物消息存储\n        putMessageResult = this.brokerController.getTransactionalMessageService().asyncPrepareMessage(msgInner);\n    } else {\n        //普通消息存储\n        putMessageResult = this.brokerController.getMessageStore().asyncPutMessage(msgInner);\n    }\n    return handlePutMessageResultFuture(putMessageResult, response, request, msgInner, responseHeader, mqtraceContext, ctx, queueIdInt);\n}\n\n```\n\n`getMessageStore`的实现默认为`DefaultMessageStore` 最后实现消息存储的为`CommitLog`或`DLedgerCommitLog`，我们主要看下`CommitLog`的实现。\n\n#### 处理消息存储\n\n```java\npublic CompletableFuture<PutMessageResult> asyncPutMessage(final MessageExtBrokerInner msg) {\n\n     ... //省略判断以及填充逻辑\n     \n    //获取消息的编码器\n    PutMessageThreadLocal putMessageThreadLocal =  this.putMessageThreadLocal.get();\n    //将消息进行编码 对应实现在`MessageExtEncoder`中 主要将上面说的消息结构 编码成bytebuffer\n    PutMessageResult encodeResult = putMessageThreadLocal.getEncoder().encode(msg);\n    //将编码结果赋值给msg的EncodeBuffer\n   msg.setEncodedBuff(putMessageThreadLocal.getEncoder().encoderBuffer);\n\n    //写入锁 这里的锁可以通过配置文件使用 CAS实现的自旋锁 或者ReentrantLock\n    putMessageLock.lock(); \n    try {\n        //获取对应的MappedFile 最后一个 没有即为空\n        MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile();\n           ....\n          \n        if (null == mappedFile || mappedFile.isFull()) {\n            //当mappedfile为空 或者已经写满了 则新创建一个mappedfile\n            mappedFile = this.mappedFileQueue.getLastMappedFile(0); \n        }\n         .....\n         // 将消息追加到mappedFile中\n        result = mappedFile.appendMessage(msg, this.appendMessageCallback, putMessageContext);\n        switch (result.getStatus()) {\n           //....\n            case END_OF_FILE:\n                unlockMappedFile = mappedFile;\n                // 写入文件过大 超过整个mappedFile的大小 新创建文件再次写入 commitlog文件尾部留有默认长度为 8个字节\n                mappedFile = this.mappedFileQueue.getLastMappedFile(0);\n                //....\n                result = mappedFile.appendMessage(msg, this.appendMessageCallback, putMessageContext);\n                break;\n           \n        }\n\n        elapsedTimeInLock = this.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;\n        beginTimeInLock = 0;\n    } finally {\n        putMessageLock.unlock();\n    }\n\n\n```\n\n通过上面代码我们可以看出来 文件创建的时机有两种，一种是第一次消息存储 内存中没有对应的`mappedFile`文件 则通过`mappedFileQueue.getLastMappedFile(0)`方式创建新的mappedFile文件， 第二种是当前最新的`mappedFile`已经无法写入新的消息了 则创建新的`mappedFile`文件.\n\n#### MappedFile文件创建\n\n```java\nif (mappedFileLast != null && mappedFileLast.isFull()) {\n    createOffset = mappedFileLast.getFileFromOffset() + this.mappedFileSize;\n}\n\nif (createOffset != -1 && needCreate) {\n    // nextFilePath 就是最后一个文件起始的offset + 最后一个文件的大小\n    String nextFilePath = this.storePath + File.separator + UtilAll.offset2FileName(createOffset);\n    \n    String nextNextFilePath = this.storePath + File.separator\n        + UtilAll.offset2FileName(createOffset + this.mappedFileSize);\n    MappedFile mappedFile = null;\n    ..... //省略部分逻辑\n       mappedFile = this.allocateMappedFileService.putRequestAndReturnMappedFile(nextFilePath,\n            nextNextFilePath, this.mappedFileSize)\n\n   \n}\n\n```\n\n```java\n    /**\n     * Only interrupted by the external thread, will return false\n     */\n    private boolean mmapOperation() {\n        boolean isSuccess = false;\n        AllocateRequest req = null;\n        try {\n            // 从队列中获取数据\n            req = this.requestQueue.take();\n           ...//省略部分过程\n\n\n            if (req.getMappedFile() == null) {\n                long beginTime = System.currentTimeMillis();\n\n                MappedFile mappedFile;\n               // 判断是否开启 isTransientStorePoolEnable ，如果开启则使用堆外内存进行写入数据，最后从堆外内存中 commit 到 FileChannel 中。\n                if (messageStore.getMessageStoreConfig().isTransientStorePoolEnable()) {\n                    try {\n                        mappedFile = ServiceLoader.load(MappedFile.class).iterator().next();\n                        mappedFile.init(req.getFilePath(), req.getFileSize(), messageStore.getTransientStorePool());\n                    } catch (RuntimeException e) {\n                        log.warn(\"Use default implementation.\");\n                        mappedFile = new MappedFile(req.getFilePath(), req.getFileSize(), messageStore.getTransientStorePool());\n                    }\n                } else {\n                    //使用mmap(RandomAccessFile#channel#map方法创建mappedByteBuffer)的方式创建MappedFile\n                    mappedFile = new MappedFile(req.getFilePath(), req.getFileSize());\n                }\n\n                long elapsedTime = UtilAll.computeElapsedTimeMilliseconds(beginTime);\n                if (elapsedTime > 10) {\n                    int queueSize = this.requestQueue.size();\n                    log.warn(\"create mappedFile spent time(ms) \" + elapsedTime + \" queue size \" + queueSize\n                        + \" \" + req.getFilePath() + \" \" + req.getFileSize());\n                }\n\n            // 判断文件大小是否大于等于1G只有commitlog才是1G文件 这里其实就是判断是否为 commitlog文件 数据预热 填充对应pagecache的数据 将mmap的数据内存映射提前准备好\n                if (mappedFile.getFileSize() >= this.messageStore.getMessageStoreConfig()\n                    .getMappedFileSizeCommitLog()\n                    &&\n                    this.messageStore.getMessageStoreConfig().isWarmMapedFileEnable()) {\n                    mappedFile.warmMappedFile(this.messageStore.getMessageStoreConfig().getFlushDiskType(),\n                        this.messageStore.getMessageStoreConfig().getFlushLeastPagesWhenWarmMapedFile());\n                }\n\n                req.setMappedFile(mappedFile);\n                this.hasException = false;\n                isSuccess = true;\n            }\n        } \n        ....\n```\n\n这里有几个关键点需要说明下 `isTransientStorePoolEnable`以及 `warmMappedFile`方法\n\n**isTransientStorePoolEnable**\n这个必须要在异步刷盘而且为master节点上才能开启, 主要是将数据写入到堆外内存中 然后通过批量commit写入到FileChannel中 这会影响到 复制到Slave节点，复制到Slave节点的数据都是已经commit的数据才会复制，所以可能会导致slave节点的数据有延迟 这个延迟受`commitIntervalCommitLog`,`commitCommitLogThoroughInterval` 默认为`200ms`配置影响\n\n\n\n### 文件过期时间\n\n消息是被顺序存储在commitlog文件中的，commitlog中因为每条消息的大小是不固定的 所以消息清理是按照时间单位进行清理的\n\n`DefaultMessageStore`中会创建一个schedule 每10s中检查一次过期文件\n\n```java\nthis.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {\n    @Override\n    public void run() {\n        DefaultMessageStore.this.cleanFilesPeriodically();\n    }\n}, 1000 * 60, this.messageStoreConfig.getCleanResourceInterval(), TimeUnit.MILLISECONDS);\n\n```\n\n清理文件包含`commitLog`和`consumeQueue`\n\n```java\nprivate void cleanFilesPeriodically() {\n    this.cleanCommitLogService.run();\n    this.cleanConsumeQueueService.run();\n}\n\n```\n\n\n\n`commitlog`中判断删除条件如下\n\n```java\nprivate void deleteExpiredFiles() {\n    int deleteCount = 0;\n    // 配置文件中的过期时间 小时为单位\n    long fileReservedTime = DefaultMessageStore.this.getMessageStoreConfig().getFileReservedTime();\n    \n     ....\n     //清理时间达到 默认为凌晨4点 deleteWhen\n    boolean timeup = this.isTimeToDelete();\n    // 磁盘空间占用率 默认为75%\n    boolean spacefull = this.isSpaceToDelete();\n    // 手动删除\n    boolean manualDelete = this.manualDeleteFileSeveralTimes > 0;\n   \n    if (timeup || spacefull || manualDelete) {\n\n        if (manualDelete)\n            this.manualDeleteFileSeveralTimes--;\n\n        boolean cleanAtOnce = DefaultMessageStore.this.getMessageStoreConfig().isCleanFileForciblyEnable() && this.cleanImmediately;\n\n        log.info(\"begin to delete before {} hours file. timeup: {} spacefull: {} manualDeleteFileSeveralTimes: {} cleanAtOnce: {}\",\n            fileReservedTime,\n            timeup,\n            spacefull,\n            manualDeleteFileSeveralTimes,\n            cleanAtOnce);\n\n        fileReservedTime *= 60 * 60 * 1000;\n\n        deleteCount = DefaultMessageStore.this.commitLog.deleteExpiredFile(fileReservedTime, deletePhysicFilesInterval,\n            destroyMapedFileIntervalForcibly, cleanAtOnce);\n        if (deleteCount > 0) {\n        } else if (spacefull) {\n            log.warn(\"disk space will be full soon, but delete file failed.\");\n        }\n    }\n}\n\n```\n\n默认过期时间为72小时也就是3天，除了我们自动清理，下面几种情况也会自动清理 无论文件是否被消费过都会被清理\n\n1、文件过期并且达到清理时间 默认是凌晨4点，自动清理过期时间\n2、文件过期 磁盘空间占用率超过75%后，无论是否到达清理时间 都会自动清理过期时间\n3、磁盘占用率达到清理阈值 默认85%后，按照设定好的清理规则(默认是时间最早的)清理文件，无论是否过期\n4、磁盘占用率达到90%后，broker拒绝消息写入\n\n\n\n## ConsumeQueue\n\n### 作用\n\nRocketmq是通过订阅Topic来消费消息的，但是因为`commitlog`是不区分topic存储消息的，如果消费者通过遍历commitlog去消费消息 那么效率就非常低下了，所以设计了`ConsumeQueue`用来存储Topic下面每一个队列中消费的offset可以将这里理解为一个队列消息对应的索引文件。\n\n\n\n### 数据格式\n\n\n```\n┌────────────────────┬─────────────────┬──────────────────┐\n│                    │                 │                  │\n│  CommitLog offset  │     Size        │  Tag hashcode    │\n│                    │                 │                  │\n│        8 byte      │    4 byte       │    8 byte        │\n│                    │                 │                  │\n└────────────────────┴─────────────────┴──────────────────┘\n```\n\n单条ConsumeQueue固定的大小是占用`20`个字节，所以每一个Consume的大小都是固定的 Consume单个文件的大小也是固定的 总共是30万条数据。\n\n```\npublic static final int CQ_STORE_UNIT_SIZE = 20;\n\n// ConsumeQueue file size,default is 30W\nprivate int mappedFileSizeConsumeQueue = 300000 * ConsumeQueue.CQ_STORE_UNIT_SIZE;\n\n```\n\n\n\n### 创建时机\n\n创建`ConsumeQueue`的时机其实是通过查询消息的时候 `consumeQueueTable`中没有当前`topic#queueid`的时候就会创建一个对应的的mappedFile文件\n\n```java\npublic ConsumeQueue findConsumeQueue(String topic, int queueId) {\n   ....\n   ConsumeQueue logic = map.get(queueId);\n   if (null == logic) {\n       //若当前内存中没有对应topic下的consumequeue 则创建对应的consumequeue\n       ConsumeQueue newLogic = new ConsumeQueue(\n           topic,\n           queueId,\n           StorePathConfigHelper.getStorePathConsumeQueue(this.messageStoreConfig.getStorePathRootDir()),\n           this.getMessageStoreConfig().getMappedFileSizeConsumeQueue(),\n           this);\n       ConsumeQueue oldLogic = map.putIfAbsent(queueId, newLogic);\n       if (oldLogic != null) {\n           logic = oldLogic;\n       } else {\n           logic = newLogic;\n       }\n   }\n\n   return logic;\n}\n\n```\n\n调用`findConsumeQueue`的位置有很多比如通过Topic和queueId获取某个队列消息的时候会使用到\n\n### 数据恢复\n\n在Broker启动的时候会触发`DefaultMessageStore#load`的方法将本地磁盘中的数据 load到内存。\n\n```java\npublic boolean load() {\n        ...\n        // load Commit Log\n        result = result && this.commitLog.load();\n\n        // load Consume Queue\n        result = result && this.loadConsumeQueue();\n        ...\n}\n\n\nprivate long recoverConsumeQueue() {\n    long maxPhysicOffset = -1;\n    for (ConcurrentMap<Integer, ConsumeQueue> maps : this.consumeQueueTable.values()) {\n        for (ConsumeQueue logic : maps.values()) {\n            logic.recover();\n            if (logic.getMaxPhysicOffset() > maxPhysicOffset) {\n                maxPhysicOffset = logic.getMaxPhysicOffset();\n            }\n        }\n    }\n\n    return maxPhysicOffset;\n}\n\n\n\n```\n\n可以看到在`DefaultMessageStore#load`方法有一个方法`loadConsumeQueue`的方法\n\n```java\nprivate boolean loadConsumeQueue() {\n    File dirLogic = new File(StorePathConfigHelper.getStorePathConsumeQueue(this.messageStoreConfig.getStorePathRootDir()));\n    //获取Store consumequeue目录下所有子目录 加载进来\n    File[] fileTopicList = dirLogic.listFiles();\n    if (fileTopicList != null) {\n        \n        for (File fileTopic : fileTopicList) {\n            String topic = fileTopic.getName();\n\n            File[] fileQueueIdList = fileTopic.listFiles();\n            if (fileQueueIdList != null) {\n                for (File fileQueueId : fileQueueIdList) {\n                    int queueId;\n                    try {\n                        queueId = Integer.parseInt(fileQueueId.getName());\n                    } catch (NumberFormatException e) {\n                        continue;\n                    }\n                    ConsumeQueue logic = new ConsumeQueue(\n                        topic,\n                        queueId,\n                        StorePathConfigHelper.getStorePathConsumeQueue(this.messageStoreConfig.getStorePathRootDir()),\n                        this.getMessageStoreConfig().getMappedFileSizeConsumeQueue(),\n                        this);\n                    this.putConsumeQueue(topic, queueId, logic);\n                    \n                }\n            }\n        }\n    }\n\n    log.info(\"load logics queue all over, OK\");\n\n    return true;\n}\n\n```\n\n`load`完之后会通过`recover`将数据初始化到堆外内存中\n\n```java\npublic void recover() {\n    final List<MappedFile> mappedFiles = this.mappedFileQueue.getMappedFiles();\n    if (!mappedFiles.isEmpty()) {\n\n        int index = mappedFiles.size() - 3;\n        if (index < 0)\n            index = 0;\n\n        int mappedFileSizeLogics = this.mappedFileSize;\n        MappedFile mappedFile = mappedFiles.get(index);\n        ByteBuffer byteBuffer = mappedFile.sliceByteBuffer();\n        long processOffset = mappedFile.getFileFromOffset();\n        long mappedFileOffset = 0;\n        long maxExtAddr = 1;\n        while (true) {\n            for (int i = 0; i < mappedFileSizeLogics; i += CQ_STORE_UNIT_SIZE)          {\n                ....//省略文件读取\n                //记录最大物理偏移\n                this.maxPhysicOffset = offset + size;\n\n                .....\n         }\n        }\n        //记录当前文件的offset\n        processOffset += mappedFileOffset;\n        this.mappedFileQueue.setFlushedWhere(processOffset);\n        this.mappedFileQueue.setCommittedWhere(processOffset);\n        this.mappedFileQueue.truncateDirtyFiles(processOffset);\n\n        if (isExtReadEnable()) {\n            this.consumeQueueExt.recover();\n            log.info(\"Truncate consume queue extend file by max {}\", maxExtAddr);\n            this.consumeQueueExt.truncateByMaxAddress(maxExtAddr);\n        }\n    }\n}\n\n```\n\n### 获取消息\n\n```java\npublic SelectMappedBufferResult getIndexBuffer(final long startIndex) {\n   int mappedFileSize = this.mappedFileSize;\n   //通过startIndex * 单条消息的大小定位offset\n   long offset = startIndex * CQ_STORE_UNIT_SIZE;\n   if (offset >= this.getMinLogicOffset()) {\n       MappedFile mappedFile = this.mappedFileQueue.findMappedFileByOffset(offset);\n       if (mappedFile != null) {\n           SelectMappedBufferResult result = mappedFile.selectMappedBuffer((int) (offset % mappedFileSize));\n           return result;\n       }\n   }\n   return null;\n}\n\n```\n\n以上代码对应`ConsumeQueue#getIndexBuffer`方法，该方法主要通过`startIndex`来获取消费消息的条目，因为每个条目的大小是固定的 所以只需要根据index*20则可以定位到具体的offset的值，就可以知道具体条目的数据`SelectMappedBufferResult`也就是开始消费的条目 然后往后消费，具体代码在`DefaultMessageStore#getMessages`方法中.\n\n```\n...\nfor (; i < bufferConsumeQueue.getSize() && i < maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) {\n    long offsetPy = bufferConsumeQueue.getByteBuffer().getLong();\n    int sizePy = bufferConsumeQueue.getByteBuffer().getInt();\n    long tagsCode = bufferConsumeQueue.getByteBuffer().getLong();\n    ....\n    \n    SelectMappedBufferResult selectResult = this.commitLog.getMessage(offsetPy, sizePy);\n\n    }\n\n```\n\n上面已经说过每一个条目中包含`commitlogOffset，size,tagCode`三个数据，那么`commitLog.getMessage(offsetPy, sizePy)`获取对应位置上的消息.\n\n### 根据时间获取消息\n\n在`ConsumeQueue#getOffsetInQueueByTime`中实现了对消息进行时间偏移读取，但是在`consumeQueue`并没有记录消息的时间，所以避免不了去`commitlog`中获取对应消息的偏移量，我们看下consumeQueue是如何实现的。\n\n```\npublic long getOffsetInQueueByTime(final long timestamp) {\n    MappedFile mappedFile = this.mappedFileQueue.getMappedFileByTime(timestamp);\n    if (mappedFile != null) {\n        long offset = 0;\n        int low = minLogicOffset > mappedFile.getFileFromOffset() ? (int) (minLogicOffset - mappedFile.getFileFromOffset()) : 0;\n        int high = 0;\n        int midOffset = -1, targetOffset = -1, leftOffset = -1, rightOffset = -1;\n        long leftIndexValue = -1L, rightIndexValue = -1L;\n        long minPhysicOffset = this.defaultMessageStore.getMinPhyOffset();\n        SelectMappedBufferResult sbr = mappedFile.selectMappedBuffer(0);\n        if (null != sbr) {\n            ByteBuffer byteBuffer = sbr.getByteBuffer();\n            high = byteBuffer.limit() - CQ_STORE_UNIT_SIZE;\n            try {\n                while (high >= low) {\n                    //通过最小偏移量和最大偏移量获取中位偏移量\n                    midOffset = (low + high) / (2 * CQ_STORE_UNIT_SIZE) * CQ_STORE_UNIT_SIZE;\n                    //...省略数据读取\n                    //从commitlog中获取当前位置消息的时间\n                    long storeTime =\n                        this.defaultMessageStore.getCommitLog().pickupStoreTimestamp(phyOffset, size);\n                    if (storeTime < 0) {\n                        return 0;\n                    } else if (storeTime == timestamp) {\n                        targetOffset = midOffset;\n                        break;\n                    } else if (storeTime > timestamp) {\n                         // 如果消息大于当前中位消息时间 则再往前进行二分查找\n                        high = midOffset - CQ_STORE_UNIT_SIZE;\n                        rightOffset = midOffset;\n                        rightIndexValue = storeTime;\n                    } else {\n                       // 如果消息大于当前中位消息时间 则再往后进行二分查找\n                        low = midOffset + CQ_STORE_UNIT_SIZE;\n                        leftOffset = midOffset;\n                        leftIndexValue = storeTime;\n                    }\n                }\n\n                if (targetOffset != -1) {\n\n                    offset = targetOffset;\n                } else {\n                    if (leftIndexValue == -1) {\n\n                        offset = rightOffset;\n                    } else if (rightIndexValue == -1) {\n\n                        offset = leftOffset;\n                    } else {\n                        offset =\n                            Math.abs(timestamp - leftIndexValue) > Math.abs(timestamp\n                                - rightIndexValue) ? rightOffset : leftOffset;\n                    }\n                }\n\n                return (mappedFile.getFileFromOffset() + offset) / CQ_STORE_UNIT_SIZE;\n            } finally {\n                sbr.release();\n            }\n        }\n    }\n    return 0;\n}\n\n```\n\n通过上面我们可以看出 rocketmq通过二分查找`consumeQueue`的方式去`commitlog`中检索对应消息的时间点进行比较。\n\n\n\n## IndexFile\n\n### 作用\n\nIndexFile 文件存储的是 包含`Key`的消息，当生产者生产消息到Broker的时候，Broker接收消息的是发现消息包含Key的时候 会将对应消息的索引记录在IndexFile中,只记录包含`Key`的消息是因为 RocketMq 可以通过制定key查询消息\n\nIndexFile 文件名称是已创建文件时间的时间戳命令 `20210901183407523`\n\n### 数据格式\n\n```\n┌────────────────────┬────────────────────┬──────────────────────┐\n│                    │                    │                      │\n│    Header          │       Slots        │        Indexes       │\n│                    │                    │                      │\n│    40 byte         │    4 byte * 500w   │   20 byte * 2000w    │\n│                    │                    │                      │\n└────────────────────┴────────────────────┴──────────────────────┘\n```\n\n### Header\n\n| 属性              | 描述                      | 类型 |\n| ----------------- | ------------------------- | ---- |\n| beginTimestamp    | 第一条消息时间戳          | Long |\n| endTimestampIndex | 最后一条消息时间戳        | Long |\n| beginPhyOffset    | 在commitlog中开始的offset | Long |\n| endPhyOffset      | 在commitlog中结束的offset | Long |\n| hashSlotCount     | 已使用的SlotCount         | Int  |\n| IndexCount        | 索引单元的数量            | Int  |\n\n索引文件中的Header 主要包含以上几个部分 所占用大小就等于 `8 + 8 + 8 + 8 + 4 + 4 = 40`个字节，在RocketMQ源码中我们可以看到`IndexHeader`类中\n\n```java\nprivate static int beginTimestampIndex = 0;\nprivate static int endTimestampIndex = 8;\nprivate static int beginPhyoffsetIndex = 16;\nprivate static int endPhyoffsetIndex = 24;\nprivate static int hashSlotcountIndex = 32;\nprivate static int indexCountIndex = 36;\n....\n\nprivate AtomicLong beginTimestamp = new AtomicLong(0);\nprivate AtomicLong endTimestamp = new AtomicLong(0);\nprivate AtomicLong beginPhyOffset = new AtomicLong(0);\nprivate AtomicLong endPhyOffset = new AtomicLong(0);\nprivate AtomicInteger hashSlotCount = new AtomicInteger(0);\nprivate AtomicInteger indexCount = new AtomicInteger(1);\n\n```\n\n### Slots\n\nSlot是槽位,每一个槽位占用4个字节也就是Int值 表示的是索引单元列表(Indexes)中当前槽位 key最新的索引值(这句话可能有点绕 通过代码和图来理解下)，在`IndexFile`类中的实现\n\n```\npublic IndexFile(final String fileName, final int hashSlotNum, final int indexNum,\n   final long endPhyOffset, final long endTimestamp) throws IOException {\n\nint fileTotalSize =\n   IndexHeader.INDEX_HEADER_SIZE + (hashSlotNum * hashSlotSize) + (indexNum * indexSize);\n   \n ....\n this.hashSlotNum = hashSlotNum;\n}\n\n\nprivate int maxHashSlotNum = 5000000;\nprivate int maxIndexNum = 5000000 * 4;\n```\n\nfileTotalSize`表示整个IndexFile文件大小是固定的，`maxHashSlotNum`表示最多槽位为500万个,`maxIndexNum`表示最多索引单元为 2000万个 那么可以知道文件大小为`500万*4 + 2000万 * 20 + 40\n\n那么每一个key如何计算所在的槽位呢？ 是通过key的hashcode 取模 500万\n\n```\nint keyHash = indexKeyHashMethod(key);\nint slotPos = keyHash % this.hashSlotNum;\n```\n\n`slotPos`就表示当前消息key所在的槽位索引\n\n每一个槽位中的值 都是**最新**索引单元 所对应`Indexes`中的索引的Position 对应源码中如下\n\n```\n// indexHead也就是40B 加上槽位索引*4B 获取当前槽位在文件中的具体position\nint absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize;\n// 通过position 取得对应槽位上的值\nint slotValue = this.mappedByteBuffer.getInt(absSlotPos);\nif (slotValue <= invalidIndex || slotValue > this.indexHeader.getIndexCount()) {\n    slotValue = invalidIndex;\n}\n\n....\n\n// 设置槽位position的最新索引值为当前索引单元的count 也就是插入进去的索引单元在 indexes中的索引\nthis.mappedByteBuffer.putInt(absSlotPos, this.indexHeader.getIndexCount());\n\n\n```\n\n\n### Indexes\n\nindex 索引单元存储 数据结构如下\n\n| 属性         | 描述                                    | 类型 |\n| ------------ | --------------------------------------- | ---- |\n| keyHash      | 消息key的hashCode                       | Int  |\n| phyOffset    | 消息在Commitlog文件中的偏移量           | Long |\n| timeDiff     | 当前消息和文件起始消息的时间差 精确到秒 | Int  |\n| preSlotValue | 上一个索引单元对应的下标值（方便理解）  | Int  |\n\n所以每一个索引单元占用的大小为 `4+8+4+4 = 20B`\n\n\n### 通过Key查询消息的流程\n\n1. 获取对应Key的HashCode\n2. 通过HashCode找到槽位\n3. 通过槽位获取最新的Index索引\n4. 通过索引中的HasCode比对 依次向上查找 这里还可以通过时间筛选\n5. 将对应符合条件的Index单元中的 commitLog的offset记录 查询对应消息","source":"_posts/broker_store.md","raw":"---\ntitle: RocketMQ存储机制详解\ndate: 2022/10/10\ndescription: CommitLog, ConsumeQueue, IndexFile源码解析.\ntag: RocketMQ\nauthor: Slide\ncategories: RocketMQ\n---\n\n## CommitLog\n\n主要存储文件以及目录包含以下几个\n\n1. **abort** 用来记录整个broker是否为安全关闭的一个状态标识 在运行起来的时候会创建abort文件 安全关闭的情况下会删除 abort文件\n2. **checkpoint** 记录 commitlog，consumequeue, index 文件最后刷盘时间戳\n3. **commitlog**  存储所有消息的一个文件夹 该文件夹下包含当前broker接受的所有消息 下面会详细介绍commitlog存储消息的格式\n4. **config**  broker运行的一些配置文件 以及consumer的消费进度等\n5. **consumequeue**  topic对应消费队列的存储 每一个topic下面为每一个queue创建了一个目录目录名称为queue的id 下面会详细描述consumequeue的结构和作用\n6. **index** 消息索引 存储的是带有key的Message 下面为详细描述Index文件的作用以及结构\n7. **lock** 运行期间用到的全局锁\n\n\n\n\n\n### 写入方式\n\n在`MessageStore`的接口定义了几种PutMessage的方式\n\n```java\n// 异步写入返回CompletableFuture\ndefault CompletableFuture<PutMessageResult> asyncPutMessage(final MessageExtBrokerInner msg) {\n    return CompletableFuture.completedFuture(putMessage(msg));\n}\n\n// 异步批量写入 返回CompletableFuture\ndefault CompletableFuture<PutMessageResult> asyncPutMessages(final MessageExtBatch messageExtBatch) {\n    return CompletableFuture.completedFuture(putMessages(messageExtBatch));\n}\n\n// 同步写入直接返回PutMessageResult\nPutMessageResult putMessage(final MessageExtBrokerInner msg);\n\n//同步批量写入PutMessageResult\nPutMessageResult putMessages(final MessageExtBatch messageExtBatch);\n\n```\n\n\n\n### 数据格式\n\ncommitlog目录下存储的就是对应具体消息，commitlog文件名称是由20个十进制的数字组成的 表示当前commitlog文件起始的文件偏移量 第一个文件肯定是`00000000000000000000`，每一个commitlog文件大小都是固定的1G，但是对应的内容是**小余等于1G**，消息为一个整体单元不可分割所以是小余等于1G的。\n\n| **属性**                  | **描述**                                                 | 类型       |\n| ------------------------- | -------------------------------------------------------- | ---------- |\n| msgLen                    | 消息长度                                                 | Int        |\n| bodyCrc                   | checksum 校验                                            | Int        |\n| queueId                   | 队列id                                                   | Long       |\n| flag                      | 用户自定义                                               | Int        |\n| queueOffset               | 队列偏移量                                               | Long       |\n| physicalOffset            | 磁盘文件偏移量                                           | Long       |\n| sysFlag                   | 用来计算FilterType和事务状态                             | Int        |\n| bornHostTimestamp         | 消息创建时间                                             | Long       |\n| bornHost                  | 生产者Host, ipv4: IP(4)+Port(4) 8 , Ipv6: IP(16)+Port(4) | 8 or 20    |\n| storeTimeStamp            | 消息存储时间                                             | Long       |\n| storehostAddressLength    | broker地址                                               | 8 or 20    |\n| reconsumeTimes            | 回收时间                                                 | Int        |\n| preparedTransactionOffset | 预处理事务消息的偏移量                                   | Int        |\n| bodyLength                | 消息体长度                                               | Int        |\n| body                      | 消息体                                                   | bodyLength |\n| topicLength               | 消息归属Topic                                            |            |\n| propertiesLength          | 配置信息                                                 |            |\n\n\n\n### 写入机制\n\n#### 发送消息请求\n\n```java\n// 解析消息头 包含消息生产者发送的一些信息以及topic和队列信息\nSendMessageRequestHeader requestHeader = parseRequestHeader(request);\nif (requestHeader == null) {\n    return CompletableFuture.completedFuture(null);\n}\n// 消息的上下文 可以用于跟踪消息trace 基本上就是reqeustHeader中的一些信息\nmqtraceContext = buildMsgContext(ctx, requestHeader);\n//注册的一些消息hook\nthis.executeSendMessageHookBefore(ctx, request, mqtraceContext);\nif (requestHeader.isBatch()) {\n    //批量消息\n    return this.asyncSendBatchMessage(ctx, request, mqtraceContext, requestHeader);\n} else {\n    //单条消息\n    return this.asyncSendMessage(ctx, request, mqtraceContext, requestHeader);\n}\n\n```\n\n```java\nprivate CompletableFuture<RemotingCommand> asyncSendMessage(ChannelHandlerContext ctx, RemotingCommand request,\n                                                            SendMessageContext mqtraceContext,\n                                                            SendMessageRequestHeader requestHeader) {\n  \n  \n \n   int queueIdInt = requestHeader.getQueueId();\n   //获取topic的配置信息\n   TopicConfig topicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n    ....\n    MessageExtBrokerInner msgInner = new MessageExtBrokerInner();\n    ... //省去填充Message数据部分\n\n    CompletableFuture<PutMessageResult> putMessageResult = null;\n    String transFlag = origProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);\n    if (transFlag != null && Boolean.parseBoolean(transFlag)) {\n        //事物消息存储\n        putMessageResult = this.brokerController.getTransactionalMessageService().asyncPrepareMessage(msgInner);\n    } else {\n        //普通消息存储\n        putMessageResult = this.brokerController.getMessageStore().asyncPutMessage(msgInner);\n    }\n    return handlePutMessageResultFuture(putMessageResult, response, request, msgInner, responseHeader, mqtraceContext, ctx, queueIdInt);\n}\n\n```\n\n`getMessageStore`的实现默认为`DefaultMessageStore` 最后实现消息存储的为`CommitLog`或`DLedgerCommitLog`，我们主要看下`CommitLog`的实现。\n\n#### 处理消息存储\n\n```java\npublic CompletableFuture<PutMessageResult> asyncPutMessage(final MessageExtBrokerInner msg) {\n\n     ... //省略判断以及填充逻辑\n     \n    //获取消息的编码器\n    PutMessageThreadLocal putMessageThreadLocal =  this.putMessageThreadLocal.get();\n    //将消息进行编码 对应实现在`MessageExtEncoder`中 主要将上面说的消息结构 编码成bytebuffer\n    PutMessageResult encodeResult = putMessageThreadLocal.getEncoder().encode(msg);\n    //将编码结果赋值给msg的EncodeBuffer\n   msg.setEncodedBuff(putMessageThreadLocal.getEncoder().encoderBuffer);\n\n    //写入锁 这里的锁可以通过配置文件使用 CAS实现的自旋锁 或者ReentrantLock\n    putMessageLock.lock(); \n    try {\n        //获取对应的MappedFile 最后一个 没有即为空\n        MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile();\n           ....\n          \n        if (null == mappedFile || mappedFile.isFull()) {\n            //当mappedfile为空 或者已经写满了 则新创建一个mappedfile\n            mappedFile = this.mappedFileQueue.getLastMappedFile(0); \n        }\n         .....\n         // 将消息追加到mappedFile中\n        result = mappedFile.appendMessage(msg, this.appendMessageCallback, putMessageContext);\n        switch (result.getStatus()) {\n           //....\n            case END_OF_FILE:\n                unlockMappedFile = mappedFile;\n                // 写入文件过大 超过整个mappedFile的大小 新创建文件再次写入 commitlog文件尾部留有默认长度为 8个字节\n                mappedFile = this.mappedFileQueue.getLastMappedFile(0);\n                //....\n                result = mappedFile.appendMessage(msg, this.appendMessageCallback, putMessageContext);\n                break;\n           \n        }\n\n        elapsedTimeInLock = this.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;\n        beginTimeInLock = 0;\n    } finally {\n        putMessageLock.unlock();\n    }\n\n\n```\n\n通过上面代码我们可以看出来 文件创建的时机有两种，一种是第一次消息存储 内存中没有对应的`mappedFile`文件 则通过`mappedFileQueue.getLastMappedFile(0)`方式创建新的mappedFile文件， 第二种是当前最新的`mappedFile`已经无法写入新的消息了 则创建新的`mappedFile`文件.\n\n#### MappedFile文件创建\n\n```java\nif (mappedFileLast != null && mappedFileLast.isFull()) {\n    createOffset = mappedFileLast.getFileFromOffset() + this.mappedFileSize;\n}\n\nif (createOffset != -1 && needCreate) {\n    // nextFilePath 就是最后一个文件起始的offset + 最后一个文件的大小\n    String nextFilePath = this.storePath + File.separator + UtilAll.offset2FileName(createOffset);\n    \n    String nextNextFilePath = this.storePath + File.separator\n        + UtilAll.offset2FileName(createOffset + this.mappedFileSize);\n    MappedFile mappedFile = null;\n    ..... //省略部分逻辑\n       mappedFile = this.allocateMappedFileService.putRequestAndReturnMappedFile(nextFilePath,\n            nextNextFilePath, this.mappedFileSize)\n\n   \n}\n\n```\n\n```java\n    /**\n     * Only interrupted by the external thread, will return false\n     */\n    private boolean mmapOperation() {\n        boolean isSuccess = false;\n        AllocateRequest req = null;\n        try {\n            // 从队列中获取数据\n            req = this.requestQueue.take();\n           ...//省略部分过程\n\n\n            if (req.getMappedFile() == null) {\n                long beginTime = System.currentTimeMillis();\n\n                MappedFile mappedFile;\n               // 判断是否开启 isTransientStorePoolEnable ，如果开启则使用堆外内存进行写入数据，最后从堆外内存中 commit 到 FileChannel 中。\n                if (messageStore.getMessageStoreConfig().isTransientStorePoolEnable()) {\n                    try {\n                        mappedFile = ServiceLoader.load(MappedFile.class).iterator().next();\n                        mappedFile.init(req.getFilePath(), req.getFileSize(), messageStore.getTransientStorePool());\n                    } catch (RuntimeException e) {\n                        log.warn(\"Use default implementation.\");\n                        mappedFile = new MappedFile(req.getFilePath(), req.getFileSize(), messageStore.getTransientStorePool());\n                    }\n                } else {\n                    //使用mmap(RandomAccessFile#channel#map方法创建mappedByteBuffer)的方式创建MappedFile\n                    mappedFile = new MappedFile(req.getFilePath(), req.getFileSize());\n                }\n\n                long elapsedTime = UtilAll.computeElapsedTimeMilliseconds(beginTime);\n                if (elapsedTime > 10) {\n                    int queueSize = this.requestQueue.size();\n                    log.warn(\"create mappedFile spent time(ms) \" + elapsedTime + \" queue size \" + queueSize\n                        + \" \" + req.getFilePath() + \" \" + req.getFileSize());\n                }\n\n            // 判断文件大小是否大于等于1G只有commitlog才是1G文件 这里其实就是判断是否为 commitlog文件 数据预热 填充对应pagecache的数据 将mmap的数据内存映射提前准备好\n                if (mappedFile.getFileSize() >= this.messageStore.getMessageStoreConfig()\n                    .getMappedFileSizeCommitLog()\n                    &&\n                    this.messageStore.getMessageStoreConfig().isWarmMapedFileEnable()) {\n                    mappedFile.warmMappedFile(this.messageStore.getMessageStoreConfig().getFlushDiskType(),\n                        this.messageStore.getMessageStoreConfig().getFlushLeastPagesWhenWarmMapedFile());\n                }\n\n                req.setMappedFile(mappedFile);\n                this.hasException = false;\n                isSuccess = true;\n            }\n        } \n        ....\n```\n\n这里有几个关键点需要说明下 `isTransientStorePoolEnable`以及 `warmMappedFile`方法\n\n**isTransientStorePoolEnable**\n这个必须要在异步刷盘而且为master节点上才能开启, 主要是将数据写入到堆外内存中 然后通过批量commit写入到FileChannel中 这会影响到 复制到Slave节点，复制到Slave节点的数据都是已经commit的数据才会复制，所以可能会导致slave节点的数据有延迟 这个延迟受`commitIntervalCommitLog`,`commitCommitLogThoroughInterval` 默认为`200ms`配置影响\n\n\n\n### 文件过期时间\n\n消息是被顺序存储在commitlog文件中的，commitlog中因为每条消息的大小是不固定的 所以消息清理是按照时间单位进行清理的\n\n`DefaultMessageStore`中会创建一个schedule 每10s中检查一次过期文件\n\n```java\nthis.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {\n    @Override\n    public void run() {\n        DefaultMessageStore.this.cleanFilesPeriodically();\n    }\n}, 1000 * 60, this.messageStoreConfig.getCleanResourceInterval(), TimeUnit.MILLISECONDS);\n\n```\n\n清理文件包含`commitLog`和`consumeQueue`\n\n```java\nprivate void cleanFilesPeriodically() {\n    this.cleanCommitLogService.run();\n    this.cleanConsumeQueueService.run();\n}\n\n```\n\n\n\n`commitlog`中判断删除条件如下\n\n```java\nprivate void deleteExpiredFiles() {\n    int deleteCount = 0;\n    // 配置文件中的过期时间 小时为单位\n    long fileReservedTime = DefaultMessageStore.this.getMessageStoreConfig().getFileReservedTime();\n    \n     ....\n     //清理时间达到 默认为凌晨4点 deleteWhen\n    boolean timeup = this.isTimeToDelete();\n    // 磁盘空间占用率 默认为75%\n    boolean spacefull = this.isSpaceToDelete();\n    // 手动删除\n    boolean manualDelete = this.manualDeleteFileSeveralTimes > 0;\n   \n    if (timeup || spacefull || manualDelete) {\n\n        if (manualDelete)\n            this.manualDeleteFileSeveralTimes--;\n\n        boolean cleanAtOnce = DefaultMessageStore.this.getMessageStoreConfig().isCleanFileForciblyEnable() && this.cleanImmediately;\n\n        log.info(\"begin to delete before {} hours file. timeup: {} spacefull: {} manualDeleteFileSeveralTimes: {} cleanAtOnce: {}\",\n            fileReservedTime,\n            timeup,\n            spacefull,\n            manualDeleteFileSeveralTimes,\n            cleanAtOnce);\n\n        fileReservedTime *= 60 * 60 * 1000;\n\n        deleteCount = DefaultMessageStore.this.commitLog.deleteExpiredFile(fileReservedTime, deletePhysicFilesInterval,\n            destroyMapedFileIntervalForcibly, cleanAtOnce);\n        if (deleteCount > 0) {\n        } else if (spacefull) {\n            log.warn(\"disk space will be full soon, but delete file failed.\");\n        }\n    }\n}\n\n```\n\n默认过期时间为72小时也就是3天，除了我们自动清理，下面几种情况也会自动清理 无论文件是否被消费过都会被清理\n\n1、文件过期并且达到清理时间 默认是凌晨4点，自动清理过期时间\n2、文件过期 磁盘空间占用率超过75%后，无论是否到达清理时间 都会自动清理过期时间\n3、磁盘占用率达到清理阈值 默认85%后，按照设定好的清理规则(默认是时间最早的)清理文件，无论是否过期\n4、磁盘占用率达到90%后，broker拒绝消息写入\n\n\n\n## ConsumeQueue\n\n### 作用\n\nRocketmq是通过订阅Topic来消费消息的，但是因为`commitlog`是不区分topic存储消息的，如果消费者通过遍历commitlog去消费消息 那么效率就非常低下了，所以设计了`ConsumeQueue`用来存储Topic下面每一个队列中消费的offset可以将这里理解为一个队列消息对应的索引文件。\n\n\n\n### 数据格式\n\n\n```\n┌────────────────────┬─────────────────┬──────────────────┐\n│                    │                 │                  │\n│  CommitLog offset  │     Size        │  Tag hashcode    │\n│                    │                 │                  │\n│        8 byte      │    4 byte       │    8 byte        │\n│                    │                 │                  │\n└────────────────────┴─────────────────┴──────────────────┘\n```\n\n单条ConsumeQueue固定的大小是占用`20`个字节，所以每一个Consume的大小都是固定的 Consume单个文件的大小也是固定的 总共是30万条数据。\n\n```\npublic static final int CQ_STORE_UNIT_SIZE = 20;\n\n// ConsumeQueue file size,default is 30W\nprivate int mappedFileSizeConsumeQueue = 300000 * ConsumeQueue.CQ_STORE_UNIT_SIZE;\n\n```\n\n\n\n### 创建时机\n\n创建`ConsumeQueue`的时机其实是通过查询消息的时候 `consumeQueueTable`中没有当前`topic#queueid`的时候就会创建一个对应的的mappedFile文件\n\n```java\npublic ConsumeQueue findConsumeQueue(String topic, int queueId) {\n   ....\n   ConsumeQueue logic = map.get(queueId);\n   if (null == logic) {\n       //若当前内存中没有对应topic下的consumequeue 则创建对应的consumequeue\n       ConsumeQueue newLogic = new ConsumeQueue(\n           topic,\n           queueId,\n           StorePathConfigHelper.getStorePathConsumeQueue(this.messageStoreConfig.getStorePathRootDir()),\n           this.getMessageStoreConfig().getMappedFileSizeConsumeQueue(),\n           this);\n       ConsumeQueue oldLogic = map.putIfAbsent(queueId, newLogic);\n       if (oldLogic != null) {\n           logic = oldLogic;\n       } else {\n           logic = newLogic;\n       }\n   }\n\n   return logic;\n}\n\n```\n\n调用`findConsumeQueue`的位置有很多比如通过Topic和queueId获取某个队列消息的时候会使用到\n\n### 数据恢复\n\n在Broker启动的时候会触发`DefaultMessageStore#load`的方法将本地磁盘中的数据 load到内存。\n\n```java\npublic boolean load() {\n        ...\n        // load Commit Log\n        result = result && this.commitLog.load();\n\n        // load Consume Queue\n        result = result && this.loadConsumeQueue();\n        ...\n}\n\n\nprivate long recoverConsumeQueue() {\n    long maxPhysicOffset = -1;\n    for (ConcurrentMap<Integer, ConsumeQueue> maps : this.consumeQueueTable.values()) {\n        for (ConsumeQueue logic : maps.values()) {\n            logic.recover();\n            if (logic.getMaxPhysicOffset() > maxPhysicOffset) {\n                maxPhysicOffset = logic.getMaxPhysicOffset();\n            }\n        }\n    }\n\n    return maxPhysicOffset;\n}\n\n\n\n```\n\n可以看到在`DefaultMessageStore#load`方法有一个方法`loadConsumeQueue`的方法\n\n```java\nprivate boolean loadConsumeQueue() {\n    File dirLogic = new File(StorePathConfigHelper.getStorePathConsumeQueue(this.messageStoreConfig.getStorePathRootDir()));\n    //获取Store consumequeue目录下所有子目录 加载进来\n    File[] fileTopicList = dirLogic.listFiles();\n    if (fileTopicList != null) {\n        \n        for (File fileTopic : fileTopicList) {\n            String topic = fileTopic.getName();\n\n            File[] fileQueueIdList = fileTopic.listFiles();\n            if (fileQueueIdList != null) {\n                for (File fileQueueId : fileQueueIdList) {\n                    int queueId;\n                    try {\n                        queueId = Integer.parseInt(fileQueueId.getName());\n                    } catch (NumberFormatException e) {\n                        continue;\n                    }\n                    ConsumeQueue logic = new ConsumeQueue(\n                        topic,\n                        queueId,\n                        StorePathConfigHelper.getStorePathConsumeQueue(this.messageStoreConfig.getStorePathRootDir()),\n                        this.getMessageStoreConfig().getMappedFileSizeConsumeQueue(),\n                        this);\n                    this.putConsumeQueue(topic, queueId, logic);\n                    \n                }\n            }\n        }\n    }\n\n    log.info(\"load logics queue all over, OK\");\n\n    return true;\n}\n\n```\n\n`load`完之后会通过`recover`将数据初始化到堆外内存中\n\n```java\npublic void recover() {\n    final List<MappedFile> mappedFiles = this.mappedFileQueue.getMappedFiles();\n    if (!mappedFiles.isEmpty()) {\n\n        int index = mappedFiles.size() - 3;\n        if (index < 0)\n            index = 0;\n\n        int mappedFileSizeLogics = this.mappedFileSize;\n        MappedFile mappedFile = mappedFiles.get(index);\n        ByteBuffer byteBuffer = mappedFile.sliceByteBuffer();\n        long processOffset = mappedFile.getFileFromOffset();\n        long mappedFileOffset = 0;\n        long maxExtAddr = 1;\n        while (true) {\n            for (int i = 0; i < mappedFileSizeLogics; i += CQ_STORE_UNIT_SIZE)          {\n                ....//省略文件读取\n                //记录最大物理偏移\n                this.maxPhysicOffset = offset + size;\n\n                .....\n         }\n        }\n        //记录当前文件的offset\n        processOffset += mappedFileOffset;\n        this.mappedFileQueue.setFlushedWhere(processOffset);\n        this.mappedFileQueue.setCommittedWhere(processOffset);\n        this.mappedFileQueue.truncateDirtyFiles(processOffset);\n\n        if (isExtReadEnable()) {\n            this.consumeQueueExt.recover();\n            log.info(\"Truncate consume queue extend file by max {}\", maxExtAddr);\n            this.consumeQueueExt.truncateByMaxAddress(maxExtAddr);\n        }\n    }\n}\n\n```\n\n### 获取消息\n\n```java\npublic SelectMappedBufferResult getIndexBuffer(final long startIndex) {\n   int mappedFileSize = this.mappedFileSize;\n   //通过startIndex * 单条消息的大小定位offset\n   long offset = startIndex * CQ_STORE_UNIT_SIZE;\n   if (offset >= this.getMinLogicOffset()) {\n       MappedFile mappedFile = this.mappedFileQueue.findMappedFileByOffset(offset);\n       if (mappedFile != null) {\n           SelectMappedBufferResult result = mappedFile.selectMappedBuffer((int) (offset % mappedFileSize));\n           return result;\n       }\n   }\n   return null;\n}\n\n```\n\n以上代码对应`ConsumeQueue#getIndexBuffer`方法，该方法主要通过`startIndex`来获取消费消息的条目，因为每个条目的大小是固定的 所以只需要根据index*20则可以定位到具体的offset的值，就可以知道具体条目的数据`SelectMappedBufferResult`也就是开始消费的条目 然后往后消费，具体代码在`DefaultMessageStore#getMessages`方法中.\n\n```\n...\nfor (; i < bufferConsumeQueue.getSize() && i < maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) {\n    long offsetPy = bufferConsumeQueue.getByteBuffer().getLong();\n    int sizePy = bufferConsumeQueue.getByteBuffer().getInt();\n    long tagsCode = bufferConsumeQueue.getByteBuffer().getLong();\n    ....\n    \n    SelectMappedBufferResult selectResult = this.commitLog.getMessage(offsetPy, sizePy);\n\n    }\n\n```\n\n上面已经说过每一个条目中包含`commitlogOffset，size,tagCode`三个数据，那么`commitLog.getMessage(offsetPy, sizePy)`获取对应位置上的消息.\n\n### 根据时间获取消息\n\n在`ConsumeQueue#getOffsetInQueueByTime`中实现了对消息进行时间偏移读取，但是在`consumeQueue`并没有记录消息的时间，所以避免不了去`commitlog`中获取对应消息的偏移量，我们看下consumeQueue是如何实现的。\n\n```\npublic long getOffsetInQueueByTime(final long timestamp) {\n    MappedFile mappedFile = this.mappedFileQueue.getMappedFileByTime(timestamp);\n    if (mappedFile != null) {\n        long offset = 0;\n        int low = minLogicOffset > mappedFile.getFileFromOffset() ? (int) (minLogicOffset - mappedFile.getFileFromOffset()) : 0;\n        int high = 0;\n        int midOffset = -1, targetOffset = -1, leftOffset = -1, rightOffset = -1;\n        long leftIndexValue = -1L, rightIndexValue = -1L;\n        long minPhysicOffset = this.defaultMessageStore.getMinPhyOffset();\n        SelectMappedBufferResult sbr = mappedFile.selectMappedBuffer(0);\n        if (null != sbr) {\n            ByteBuffer byteBuffer = sbr.getByteBuffer();\n            high = byteBuffer.limit() - CQ_STORE_UNIT_SIZE;\n            try {\n                while (high >= low) {\n                    //通过最小偏移量和最大偏移量获取中位偏移量\n                    midOffset = (low + high) / (2 * CQ_STORE_UNIT_SIZE) * CQ_STORE_UNIT_SIZE;\n                    //...省略数据读取\n                    //从commitlog中获取当前位置消息的时间\n                    long storeTime =\n                        this.defaultMessageStore.getCommitLog().pickupStoreTimestamp(phyOffset, size);\n                    if (storeTime < 0) {\n                        return 0;\n                    } else if (storeTime == timestamp) {\n                        targetOffset = midOffset;\n                        break;\n                    } else if (storeTime > timestamp) {\n                         // 如果消息大于当前中位消息时间 则再往前进行二分查找\n                        high = midOffset - CQ_STORE_UNIT_SIZE;\n                        rightOffset = midOffset;\n                        rightIndexValue = storeTime;\n                    } else {\n                       // 如果消息大于当前中位消息时间 则再往后进行二分查找\n                        low = midOffset + CQ_STORE_UNIT_SIZE;\n                        leftOffset = midOffset;\n                        leftIndexValue = storeTime;\n                    }\n                }\n\n                if (targetOffset != -1) {\n\n                    offset = targetOffset;\n                } else {\n                    if (leftIndexValue == -1) {\n\n                        offset = rightOffset;\n                    } else if (rightIndexValue == -1) {\n\n                        offset = leftOffset;\n                    } else {\n                        offset =\n                            Math.abs(timestamp - leftIndexValue) > Math.abs(timestamp\n                                - rightIndexValue) ? rightOffset : leftOffset;\n                    }\n                }\n\n                return (mappedFile.getFileFromOffset() + offset) / CQ_STORE_UNIT_SIZE;\n            } finally {\n                sbr.release();\n            }\n        }\n    }\n    return 0;\n}\n\n```\n\n通过上面我们可以看出 rocketmq通过二分查找`consumeQueue`的方式去`commitlog`中检索对应消息的时间点进行比较。\n\n\n\n## IndexFile\n\n### 作用\n\nIndexFile 文件存储的是 包含`Key`的消息，当生产者生产消息到Broker的时候，Broker接收消息的是发现消息包含Key的时候 会将对应消息的索引记录在IndexFile中,只记录包含`Key`的消息是因为 RocketMq 可以通过制定key查询消息\n\nIndexFile 文件名称是已创建文件时间的时间戳命令 `20210901183407523`\n\n### 数据格式\n\n```\n┌────────────────────┬────────────────────┬──────────────────────┐\n│                    │                    │                      │\n│    Header          │       Slots        │        Indexes       │\n│                    │                    │                      │\n│    40 byte         │    4 byte * 500w   │   20 byte * 2000w    │\n│                    │                    │                      │\n└────────────────────┴────────────────────┴──────────────────────┘\n```\n\n### Header\n\n| 属性              | 描述                      | 类型 |\n| ----------------- | ------------------------- | ---- |\n| beginTimestamp    | 第一条消息时间戳          | Long |\n| endTimestampIndex | 最后一条消息时间戳        | Long |\n| beginPhyOffset    | 在commitlog中开始的offset | Long |\n| endPhyOffset      | 在commitlog中结束的offset | Long |\n| hashSlotCount     | 已使用的SlotCount         | Int  |\n| IndexCount        | 索引单元的数量            | Int  |\n\n索引文件中的Header 主要包含以上几个部分 所占用大小就等于 `8 + 8 + 8 + 8 + 4 + 4 = 40`个字节，在RocketMQ源码中我们可以看到`IndexHeader`类中\n\n```java\nprivate static int beginTimestampIndex = 0;\nprivate static int endTimestampIndex = 8;\nprivate static int beginPhyoffsetIndex = 16;\nprivate static int endPhyoffsetIndex = 24;\nprivate static int hashSlotcountIndex = 32;\nprivate static int indexCountIndex = 36;\n....\n\nprivate AtomicLong beginTimestamp = new AtomicLong(0);\nprivate AtomicLong endTimestamp = new AtomicLong(0);\nprivate AtomicLong beginPhyOffset = new AtomicLong(0);\nprivate AtomicLong endPhyOffset = new AtomicLong(0);\nprivate AtomicInteger hashSlotCount = new AtomicInteger(0);\nprivate AtomicInteger indexCount = new AtomicInteger(1);\n\n```\n\n### Slots\n\nSlot是槽位,每一个槽位占用4个字节也就是Int值 表示的是索引单元列表(Indexes)中当前槽位 key最新的索引值(这句话可能有点绕 通过代码和图来理解下)，在`IndexFile`类中的实现\n\n```\npublic IndexFile(final String fileName, final int hashSlotNum, final int indexNum,\n   final long endPhyOffset, final long endTimestamp) throws IOException {\n\nint fileTotalSize =\n   IndexHeader.INDEX_HEADER_SIZE + (hashSlotNum * hashSlotSize) + (indexNum * indexSize);\n   \n ....\n this.hashSlotNum = hashSlotNum;\n}\n\n\nprivate int maxHashSlotNum = 5000000;\nprivate int maxIndexNum = 5000000 * 4;\n```\n\nfileTotalSize`表示整个IndexFile文件大小是固定的，`maxHashSlotNum`表示最多槽位为500万个,`maxIndexNum`表示最多索引单元为 2000万个 那么可以知道文件大小为`500万*4 + 2000万 * 20 + 40\n\n那么每一个key如何计算所在的槽位呢？ 是通过key的hashcode 取模 500万\n\n```\nint keyHash = indexKeyHashMethod(key);\nint slotPos = keyHash % this.hashSlotNum;\n```\n\n`slotPos`就表示当前消息key所在的槽位索引\n\n每一个槽位中的值 都是**最新**索引单元 所对应`Indexes`中的索引的Position 对应源码中如下\n\n```\n// indexHead也就是40B 加上槽位索引*4B 获取当前槽位在文件中的具体position\nint absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize;\n// 通过position 取得对应槽位上的值\nint slotValue = this.mappedByteBuffer.getInt(absSlotPos);\nif (slotValue <= invalidIndex || slotValue > this.indexHeader.getIndexCount()) {\n    slotValue = invalidIndex;\n}\n\n....\n\n// 设置槽位position的最新索引值为当前索引单元的count 也就是插入进去的索引单元在 indexes中的索引\nthis.mappedByteBuffer.putInt(absSlotPos, this.indexHeader.getIndexCount());\n\n\n```\n\n\n### Indexes\n\nindex 索引单元存储 数据结构如下\n\n| 属性         | 描述                                    | 类型 |\n| ------------ | --------------------------------------- | ---- |\n| keyHash      | 消息key的hashCode                       | Int  |\n| phyOffset    | 消息在Commitlog文件中的偏移量           | Long |\n| timeDiff     | 当前消息和文件起始消息的时间差 精确到秒 | Int  |\n| preSlotValue | 上一个索引单元对应的下标值（方便理解）  | Int  |\n\n所以每一个索引单元占用的大小为 `4+8+4+4 = 20B`\n\n\n### 通过Key查询消息的流程\n\n1. 获取对应Key的HashCode\n2. 通过HashCode找到槽位\n3. 通过槽位获取最新的Index索引\n4. 通过索引中的HasCode比对 依次向上查找 这里还可以通过时间筛选\n5. 将对应符合条件的Index单元中的 commitLog的offset记录 查询对应消息","slug":"broker_store","published":1,"updated":"2022-10-16T04:35:49.813Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9axa88g0001m1rggo0zbm0r","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"CommitLog\"><a href=\"#CommitLog\" class=\"headerlink\" title=\"CommitLog\"></a>CommitLog</h2><p>主要存储文件以及目录包含以下几个</p>\n<ol>\n<li><strong>abort</strong> 用来记录整个broker是否为安全关闭的一个状态标识 在运行起来的时候会创建abort文件 安全关闭的情况下会删除 abort文件</li>\n<li><strong>checkpoint</strong> 记录 commitlog，consumequeue, index 文件最后刷盘时间戳</li>\n<li><strong>commitlog</strong>  存储所有消息的一个文件夹 该文件夹下包含当前broker接受的所有消息 下面会详细介绍commitlog存储消息的格式</li>\n<li><strong>config</strong>  broker运行的一些配置文件 以及consumer的消费进度等</li>\n<li><strong>consumequeue</strong>  topic对应消费队列的存储 每一个topic下面为每一个queue创建了一个目录目录名称为queue的id 下面会详细描述consumequeue的结构和作用</li>\n<li><strong>index</strong> 消息索引 存储的是带有key的Message 下面为详细描述Index文件的作用以及结构</li>\n<li><strong>lock</strong> 运行期间用到的全局锁</li>\n</ol>\n<h3 id=\"写入方式\"><a href=\"#写入方式\" class=\"headerlink\" title=\"写入方式\"></a>写入方式</h3><p>在<code>MessageStore</code>的接口定义了几种PutMessage的方式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 异步写入返回CompletableFuture</span></span><br><span class=\"line\"><span class=\"keyword\">default</span> CompletableFuture&lt;PutMessageResult&gt; <span class=\"title function_\">asyncPutMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageExtBrokerInner msg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> CompletableFuture.completedFuture(putMessage(msg));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 异步批量写入 返回CompletableFuture</span></span><br><span class=\"line\"><span class=\"keyword\">default</span> CompletableFuture&lt;PutMessageResult&gt; <span class=\"title function_\">asyncPutMessages</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageExtBatch messageExtBatch)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> CompletableFuture.completedFuture(putMessages(messageExtBatch));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同步写入直接返回PutMessageResult</span></span><br><span class=\"line\">PutMessageResult <span class=\"title function_\">putMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageExtBrokerInner msg)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//同步批量写入PutMessageResult</span></span><br><span class=\"line\">PutMessageResult <span class=\"title function_\">putMessages</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageExtBatch messageExtBatch)</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"数据格式\"><a href=\"#数据格式\" class=\"headerlink\" title=\"数据格式\"></a>数据格式</h3><p>commitlog目录下存储的就是对应具体消息，commitlog文件名称是由20个十进制的数字组成的 表示当前commitlog文件起始的文件偏移量 第一个文件肯定是<code>00000000000000000000</code>，每一个commitlog文件大小都是固定的1G，但是对应的内容是<strong>小余等于1G</strong>，消息为一个整体单元不可分割所以是小余等于1G的。</p>\n<table>\n<thead>\n<tr>\n<th><strong>属性</strong></th>\n<th><strong>描述</strong></th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>msgLen</td>\n<td>消息长度</td>\n<td>Int</td>\n</tr>\n<tr>\n<td>bodyCrc</td>\n<td>checksum 校验</td>\n<td>Int</td>\n</tr>\n<tr>\n<td>queueId</td>\n<td>队列id</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>flag</td>\n<td>用户自定义</td>\n<td>Int</td>\n</tr>\n<tr>\n<td>queueOffset</td>\n<td>队列偏移量</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>physicalOffset</td>\n<td>磁盘文件偏移量</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>sysFlag</td>\n<td>用来计算FilterType和事务状态</td>\n<td>Int</td>\n</tr>\n<tr>\n<td>bornHostTimestamp</td>\n<td>消息创建时间</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>bornHost</td>\n<td>生产者Host, ipv4: IP(4)+Port(4) 8 , Ipv6: IP(16)+Port(4)</td>\n<td>8 or 20</td>\n</tr>\n<tr>\n<td>storeTimeStamp</td>\n<td>消息存储时间</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>storehostAddressLength</td>\n<td>broker地址</td>\n<td>8 or 20</td>\n</tr>\n<tr>\n<td>reconsumeTimes</td>\n<td>回收时间</td>\n<td>Int</td>\n</tr>\n<tr>\n<td>preparedTransactionOffset</td>\n<td>预处理事务消息的偏移量</td>\n<td>Int</td>\n</tr>\n<tr>\n<td>bodyLength</td>\n<td>消息体长度</td>\n<td>Int</td>\n</tr>\n<tr>\n<td>body</td>\n<td>消息体</td>\n<td>bodyLength</td>\n</tr>\n<tr>\n<td>topicLength</td>\n<td>消息归属Topic</td>\n<td></td>\n</tr>\n<tr>\n<td>propertiesLength</td>\n<td>配置信息</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"写入机制\"><a href=\"#写入机制\" class=\"headerlink\" title=\"写入机制\"></a>写入机制</h3><h4 id=\"发送消息请求\"><a href=\"#发送消息请求\" class=\"headerlink\" title=\"发送消息请求\"></a>发送消息请求</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 解析消息头 包含消息生产者发送的一些信息以及topic和队列信息</span></span><br><span class=\"line\"><span class=\"type\">SendMessageRequestHeader</span> <span class=\"variable\">requestHeader</span> <span class=\"operator\">=</span> parseRequestHeader(request);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (requestHeader == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> CompletableFuture.completedFuture(<span class=\"literal\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 消息的上下文 可以用于跟踪消息trace 基本上就是reqeustHeader中的一些信息</span></span><br><span class=\"line\">mqtraceContext = buildMsgContext(ctx, requestHeader);</span><br><span class=\"line\"><span class=\"comment\">//注册的一些消息hook</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.executeSendMessageHookBefore(ctx, request, mqtraceContext);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (requestHeader.isBatch()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//批量消息</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.asyncSendBatchMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//单条消息</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.asyncSendMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> CompletableFuture&lt;RemotingCommand&gt; <span class=\"title function_\">asyncSendMessage</span><span class=\"params\">(ChannelHandlerContext ctx, RemotingCommand request,</span></span><br><span class=\"line\"><span class=\"params\">                                                            SendMessageContext mqtraceContext,</span></span><br><span class=\"line\"><span class=\"params\">                                                            SendMessageRequestHeader requestHeader)</span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"type\">int</span> <span class=\"variable\">queueIdInt</span> <span class=\"operator\">=</span> requestHeader.getQueueId();</span><br><span class=\"line\">   <span class=\"comment\">//获取topic的配置信息</span></span><br><span class=\"line\">   <span class=\"type\">TopicConfig</span> <span class=\"variable\">topicConfig</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</span><br><span class=\"line\">    ....</span><br><span class=\"line\">    <span class=\"type\">MessageExtBrokerInner</span> <span class=\"variable\">msgInner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageExtBrokerInner</span>();</span><br><span class=\"line\">    ... <span class=\"comment\">//省去填充Message数据部分</span></span><br><span class=\"line\"></span><br><span class=\"line\">    CompletableFuture&lt;PutMessageResult&gt; putMessageResult = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">transFlag</span> <span class=\"operator\">=</span> origProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (transFlag != <span class=\"literal\">null</span> &amp;&amp; Boolean.parseBoolean(transFlag)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//事物消息存储</span></span><br><span class=\"line\">        putMessageResult = <span class=\"built_in\">this</span>.brokerController.getTransactionalMessageService().asyncPrepareMessage(msgInner);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//普通消息存储</span></span><br><span class=\"line\">        putMessageResult = <span class=\"built_in\">this</span>.brokerController.getMessageStore().asyncPutMessage(msgInner);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> handlePutMessageResultFuture(putMessageResult, response, request, msgInner, responseHeader, mqtraceContext, ctx, queueIdInt);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>getMessageStore</code>的实现默认为<code>DefaultMessageStore</code> 最后实现消息存储的为<code>CommitLog</code>或<code>DLedgerCommitLog</code>，我们主要看下<code>CommitLog</code>的实现。</p>\n<h4 id=\"处理消息存储\"><a href=\"#处理消息存储\" class=\"headerlink\" title=\"处理消息存储\"></a>处理消息存储</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;PutMessageResult&gt; <span class=\"title function_\">asyncPutMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageExtBrokerInner msg)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     ... <span class=\"comment\">//省略判断以及填充逻辑</span></span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"comment\">//获取消息的编码器</span></span><br><span class=\"line\">    <span class=\"type\">PutMessageThreadLocal</span> <span class=\"variable\">putMessageThreadLocal</span> <span class=\"operator\">=</span>  <span class=\"built_in\">this</span>.putMessageThreadLocal.get();</span><br><span class=\"line\">    <span class=\"comment\">//将消息进行编码 对应实现在`MessageExtEncoder`中 主要将上面说的消息结构 编码成bytebuffer</span></span><br><span class=\"line\">    <span class=\"type\">PutMessageResult</span> <span class=\"variable\">encodeResult</span> <span class=\"operator\">=</span> putMessageThreadLocal.getEncoder().encode(msg);</span><br><span class=\"line\">    <span class=\"comment\">//将编码结果赋值给msg的EncodeBuffer</span></span><br><span class=\"line\">   msg.setEncodedBuff(putMessageThreadLocal.getEncoder().encoderBuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//写入锁 这里的锁可以通过配置文件使用 CAS实现的自旋锁 或者ReentrantLock</span></span><br><span class=\"line\">    putMessageLock.lock(); </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取对应的MappedFile 最后一个 没有即为空</span></span><br><span class=\"line\">        <span class=\"type\">MappedFile</span> <span class=\"variable\">mappedFile</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.mappedFileQueue.getLastMappedFile();</span><br><span class=\"line\">           ....</span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> == mappedFile || mappedFile.isFull()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//当mappedfile为空 或者已经写满了 则新创建一个mappedfile</span></span><br><span class=\"line\">            mappedFile = <span class=\"built_in\">this</span>.mappedFileQueue.getLastMappedFile(<span class=\"number\">0</span>); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         .....</span><br><span class=\"line\">         <span class=\"comment\">// 将消息追加到mappedFile中</span></span><br><span class=\"line\">        result = mappedFile.appendMessage(msg, <span class=\"built_in\">this</span>.appendMessageCallback, putMessageContext);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (result.getStatus()) &#123;</span><br><span class=\"line\">           <span class=\"comment\">//....</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> END_OF_FILE:</span><br><span class=\"line\">                unlockMappedFile = mappedFile;</span><br><span class=\"line\">                <span class=\"comment\">// 写入文件过大 超过整个mappedFile的大小 新创建文件再次写入 commitlog文件尾部留有默认长度为 8个字节</span></span><br><span class=\"line\">                mappedFile = <span class=\"built_in\">this</span>.mappedFileQueue.getLastMappedFile(<span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"comment\">//....</span></span><br><span class=\"line\">                result = mappedFile.appendMessage(msg, <span class=\"built_in\">this</span>.appendMessageCallback, putMessageContext);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        elapsedTimeInLock = <span class=\"built_in\">this</span>.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;</span><br><span class=\"line\">        beginTimeInLock = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        putMessageLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>通过上面代码我们可以看出来 文件创建的时机有两种，一种是第一次消息存储 内存中没有对应的<code>mappedFile</code>文件 则通过<code>mappedFileQueue.getLastMappedFile(0)</code>方式创建新的mappedFile文件， 第二种是当前最新的<code>mappedFile</code>已经无法写入新的消息了 则创建新的<code>mappedFile</code>文件.</p>\n<h4 id=\"MappedFile文件创建\"><a href=\"#MappedFile文件创建\" class=\"headerlink\" title=\"MappedFile文件创建\"></a>MappedFile文件创建</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mappedFileLast != <span class=\"literal\">null</span> &amp;&amp; mappedFileLast.isFull()) &#123;</span><br><span class=\"line\">    createOffset = mappedFileLast.getFileFromOffset() + <span class=\"built_in\">this</span>.mappedFileSize;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (createOffset != -<span class=\"number\">1</span> &amp;&amp; needCreate) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// nextFilePath 就是最后一个文件起始的offset + 最后一个文件的大小</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">nextFilePath</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.storePath + File.separator + UtilAll.offset2FileName(createOffset);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">nextNextFilePath</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.storePath + File.separator</span><br><span class=\"line\">        + UtilAll.offset2FileName(createOffset + <span class=\"built_in\">this</span>.mappedFileSize);</span><br><span class=\"line\">    <span class=\"type\">MappedFile</span> <span class=\"variable\">mappedFile</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    ..... <span class=\"comment\">//省略部分逻辑</span></span><br><span class=\"line\">       mappedFile = <span class=\"built_in\">this</span>.allocateMappedFileService.putRequestAndReturnMappedFile(nextFilePath,</span><br><span class=\"line\">            nextNextFilePath, <span class=\"built_in\">this</span>.mappedFileSize)</span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Only interrupted by the external thread, will return false</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">mmapOperation</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">isSuccess</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"type\">AllocateRequest</span> <span class=\"variable\">req</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从队列中获取数据</span></span><br><span class=\"line\">        req = <span class=\"built_in\">this</span>.requestQueue.take();</span><br><span class=\"line\">       ...<span class=\"comment\">//省略部分过程</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.getMappedFile() == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">beginTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">            MappedFile mappedFile;</span><br><span class=\"line\">           <span class=\"comment\">// 判断是否开启 isTransientStorePoolEnable ，如果开启则使用堆外内存进行写入数据，最后从堆外内存中 commit 到 FileChannel 中。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (messageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    mappedFile = ServiceLoader.load(MappedFile.class).iterator().next();</span><br><span class=\"line\">                    mappedFile.init(req.getFilePath(), req.getFileSize(), messageStore.getTransientStorePool());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123;</span><br><span class=\"line\">                    log.warn(<span class=\"string\">&quot;Use default implementation.&quot;</span>);</span><br><span class=\"line\">                    mappedFile = <span class=\"keyword\">new</span> <span class=\"title class_\">MappedFile</span>(req.getFilePath(), req.getFileSize(), messageStore.getTransientStorePool());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//使用mmap(RandomAccessFile#channel#map方法创建mappedByteBuffer)的方式创建MappedFile</span></span><br><span class=\"line\">                mappedFile = <span class=\"keyword\">new</span> <span class=\"title class_\">MappedFile</span>(req.getFilePath(), req.getFileSize());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">elapsedTime</span> <span class=\"operator\">=</span> UtilAll.computeElapsedTimeMilliseconds(beginTime);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elapsedTime &gt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">queueSize</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.requestQueue.size();</span><br><span class=\"line\">                log.warn(<span class=\"string\">&quot;create mappedFile spent time(ms) &quot;</span> + elapsedTime + <span class=\"string\">&quot; queue size &quot;</span> + queueSize</span><br><span class=\"line\">                    + <span class=\"string\">&quot; &quot;</span> + req.getFilePath() + <span class=\"string\">&quot; &quot;</span> + req.getFileSize());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断文件大小是否大于等于1G只有commitlog才是1G文件 这里其实就是判断是否为 commitlog文件 数据预热 填充对应pagecache的数据 将mmap的数据内存映射提前准备好</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mappedFile.getFileSize() &gt;= <span class=\"built_in\">this</span>.messageStore.getMessageStoreConfig()</span><br><span class=\"line\">                .getMappedFileSizeCommitLog()</span><br><span class=\"line\">                &amp;&amp;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.messageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;</span><br><span class=\"line\">                mappedFile.warmMappedFile(<span class=\"built_in\">this</span>.messageStore.getMessageStoreConfig().getFlushDiskType(),</span><br><span class=\"line\">                    <span class=\"built_in\">this</span>.messageStore.getMessageStoreConfig().getFlushLeastPagesWhenWarmMapedFile());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            req.setMappedFile(mappedFile);</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.hasException = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            isSuccess = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    ....</span><br></pre></td></tr></table></figure>\n\n<p>这里有几个关键点需要说明下 <code>isTransientStorePoolEnable</code>以及 <code>warmMappedFile</code>方法</p>\n<p><strong>isTransientStorePoolEnable</strong><br>这个必须要在异步刷盘而且为master节点上才能开启, 主要是将数据写入到堆外内存中 然后通过批量commit写入到FileChannel中 这会影响到 复制到Slave节点，复制到Slave节点的数据都是已经commit的数据才会复制，所以可能会导致slave节点的数据有延迟 这个延迟受<code>commitIntervalCommitLog</code>,<code>commitCommitLogThoroughInterval</code> 默认为<code>200ms</code>配置影响</p>\n<h3 id=\"文件过期时间\"><a href=\"#文件过期时间\" class=\"headerlink\" title=\"文件过期时间\"></a>文件过期时间</h3><p>消息是被顺序存储在commitlog文件中的，commitlog中因为每条消息的大小是不固定的 所以消息清理是按照时间单位进行清理的</p>\n<p><code>DefaultMessageStore</code>中会创建一个schedule 每10s中检查一次过期文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        DefaultMessageStore.<span class=\"built_in\">this</span>.cleanFilesPeriodically();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span> * <span class=\"number\">60</span>, <span class=\"built_in\">this</span>.messageStoreConfig.getCleanResourceInterval(), TimeUnit.MILLISECONDS);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>清理文件包含<code>commitLog</code>和<code>consumeQueue</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">cleanFilesPeriodically</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.cleanCommitLogService.run();</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.cleanConsumeQueueService.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>commitlog</code>中判断删除条件如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">deleteExpiredFiles</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">deleteCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 配置文件中的过期时间 小时为单位</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">fileReservedTime</span> <span class=\"operator\">=</span> DefaultMessageStore.<span class=\"built_in\">this</span>.getMessageStoreConfig().getFileReservedTime();</span><br><span class=\"line\">    </span><br><span class=\"line\">     ....</span><br><span class=\"line\">     <span class=\"comment\">//清理时间达到 默认为凌晨4点 deleteWhen</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">timeup</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.isTimeToDelete();</span><br><span class=\"line\">    <span class=\"comment\">// 磁盘空间占用率 默认为75%</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">spacefull</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.isSpaceToDelete();</span><br><span class=\"line\">    <span class=\"comment\">// 手动删除</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">manualDelete</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.manualDeleteFileSeveralTimes &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timeup || spacefull || manualDelete) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (manualDelete)</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.manualDeleteFileSeveralTimes--;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">cleanAtOnce</span> <span class=\"operator\">=</span> DefaultMessageStore.<span class=\"built_in\">this</span>.getMessageStoreConfig().isCleanFileForciblyEnable() &amp;&amp; <span class=\"built_in\">this</span>.cleanImmediately;</span><br><span class=\"line\"></span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;begin to delete before &#123;&#125; hours file. timeup: &#123;&#125; spacefull: &#123;&#125; manualDeleteFileSeveralTimes: &#123;&#125; cleanAtOnce: &#123;&#125;&quot;</span>,</span><br><span class=\"line\">            fileReservedTime,</span><br><span class=\"line\">            timeup,</span><br><span class=\"line\">            spacefull,</span><br><span class=\"line\">            manualDeleteFileSeveralTimes,</span><br><span class=\"line\">            cleanAtOnce);</span><br><span class=\"line\"></span><br><span class=\"line\">        fileReservedTime *= <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        deleteCount = DefaultMessageStore.<span class=\"built_in\">this</span>.commitLog.deleteExpiredFile(fileReservedTime, deletePhysicFilesInterval,</span><br><span class=\"line\">            destroyMapedFileIntervalForcibly, cleanAtOnce);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (deleteCount &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (spacefull) &#123;</span><br><span class=\"line\">            log.warn(<span class=\"string\">&quot;disk space will be full soon, but delete file failed.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>默认过期时间为72小时也就是3天，除了我们自动清理，下面几种情况也会自动清理 无论文件是否被消费过都会被清理</p>\n<p>1、文件过期并且达到清理时间 默认是凌晨4点，自动清理过期时间<br>2、文件过期 磁盘空间占用率超过75%后，无论是否到达清理时间 都会自动清理过期时间<br>3、磁盘占用率达到清理阈值 默认85%后，按照设定好的清理规则(默认是时间最早的)清理文件，无论是否过期<br>4、磁盘占用率达到90%后，broker拒绝消息写入</p>\n<h2 id=\"ConsumeQueue\"><a href=\"#ConsumeQueue\" class=\"headerlink\" title=\"ConsumeQueue\"></a>ConsumeQueue</h2><h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><p>Rocketmq是通过订阅Topic来消费消息的，但是因为<code>commitlog</code>是不区分topic存储消息的，如果消费者通过遍历commitlog去消费消息 那么效率就非常低下了，所以设计了<code>ConsumeQueue</code>用来存储Topic下面每一个队列中消费的offset可以将这里理解为一个队列消息对应的索引文件。</p>\n<h3 id=\"数据格式-1\"><a href=\"#数据格式-1\" class=\"headerlink\" title=\"数据格式\"></a>数据格式</h3><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">┌────────────────────┬─────────────────┬──────────────────┐</span><br><span class=\"line\">│                    │                 │                  │</span><br><span class=\"line\">│  CommitLog offset  │     <span class=\"keyword\">Size</span>        │  Tag hashcode    │</span><br><span class=\"line\">│                    │                 │                  │</span><br><span class=\"line\">│        <span class=\"number\">8</span> <span class=\"keyword\">byte</span>      │    <span class=\"number\">4</span> <span class=\"keyword\">byte</span>       │    <span class=\"number\">8</span> <span class=\"keyword\">byte</span>        │</span><br><span class=\"line\">│                    │                 │                  │</span><br><span class=\"line\">└────────────────────┴─────────────────┴──────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>单条ConsumeQueue固定的大小是占用<code>20</code>个字节，所以每一个Consume的大小都是固定的 Consume单个文件的大小也是固定的 总共是30万条数据。</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> static <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> CQ_STORE_UNIT_SIZE = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">// ConsumeQueue <span class=\"keyword\">file</span> <span class=\"built_in\">size</span>,<span class=\"keyword\">default</span> is <span class=\"number\">30</span>W</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"built_in\">int</span> mappedFileSizeConsumeQueue = <span class=\"number\">300000</span> * ConsumeQueue.CQ_STORE_UNIT_SIZE;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"创建时机\"><a href=\"#创建时机\" class=\"headerlink\" title=\"创建时机\"></a>创建时机</h3><p>创建<code>ConsumeQueue</code>的时机其实是通过查询消息的时候 <code>consumeQueueTable</code>中没有当前<code>topic#queueid</code>的时候就会创建一个对应的的mappedFile文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ConsumeQueue <span class=\"title function_\">findConsumeQueue</span><span class=\"params\">(String topic, <span class=\"type\">int</span> queueId)</span> &#123;</span><br><span class=\"line\">   ....</span><br><span class=\"line\">   <span class=\"type\">ConsumeQueue</span> <span class=\"variable\">logic</span> <span class=\"operator\">=</span> map.get(queueId);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> == logic) &#123;</span><br><span class=\"line\">       <span class=\"comment\">//若当前内存中没有对应topic下的consumequeue 则创建对应的consumequeue</span></span><br><span class=\"line\">       <span class=\"type\">ConsumeQueue</span> <span class=\"variable\">newLogic</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConsumeQueue</span>(</span><br><span class=\"line\">           topic,</span><br><span class=\"line\">           queueId,</span><br><span class=\"line\">           StorePathConfigHelper.getStorePathConsumeQueue(<span class=\"built_in\">this</span>.messageStoreConfig.getStorePathRootDir()),</span><br><span class=\"line\">           <span class=\"built_in\">this</span>.getMessageStoreConfig().getMappedFileSizeConsumeQueue(),</span><br><span class=\"line\">           <span class=\"built_in\">this</span>);</span><br><span class=\"line\">       <span class=\"type\">ConsumeQueue</span> <span class=\"variable\">oldLogic</span> <span class=\"operator\">=</span> map.putIfAbsent(queueId, newLogic);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (oldLogic != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           logic = oldLogic;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           logic = newLogic;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> logic;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>调用<code>findConsumeQueue</code>的位置有很多比如通过Topic和queueId获取某个队列消息的时候会使用到</p>\n<h3 id=\"数据恢复\"><a href=\"#数据恢复\" class=\"headerlink\" title=\"数据恢复\"></a>数据恢复</h3><p>在Broker启动的时候会触发<code>DefaultMessageStore#load</code>的方法将本地磁盘中的数据 load到内存。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">load</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// load Commit Log</span></span><br><span class=\"line\">        result = result &amp;&amp; <span class=\"built_in\">this</span>.commitLog.load();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// load Consume Queue</span></span><br><span class=\"line\">        result = result &amp;&amp; <span class=\"built_in\">this</span>.loadConsumeQueue();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"title function_\">recoverConsumeQueue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">maxPhysicOffset</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ConcurrentMap&lt;Integer, ConsumeQueue&gt; maps : <span class=\"built_in\">this</span>.consumeQueueTable.values()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ConsumeQueue logic : maps.values()) &#123;</span><br><span class=\"line\">            logic.recover();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (logic.getMaxPhysicOffset() &gt; maxPhysicOffset) &#123;</span><br><span class=\"line\">                maxPhysicOffset = logic.getMaxPhysicOffset();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxPhysicOffset;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>可以看到在<code>DefaultMessageStore#load</code>方法有一个方法<code>loadConsumeQueue</code>的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">loadConsumeQueue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">dirLogic</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(StorePathConfigHelper.getStorePathConsumeQueue(<span class=\"built_in\">this</span>.messageStoreConfig.getStorePathRootDir()));</span><br><span class=\"line\">    <span class=\"comment\">//获取Store consumequeue目录下所有子目录 加载进来</span></span><br><span class=\"line\">    File[] fileTopicList = dirLogic.listFiles();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fileTopicList != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (File fileTopic : fileTopicList) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">topic</span> <span class=\"operator\">=</span> fileTopic.getName();</span><br><span class=\"line\"></span><br><span class=\"line\">            File[] fileQueueIdList = fileTopic.listFiles();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fileQueueIdList != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (File fileQueueId : fileQueueIdList) &#123;</span><br><span class=\"line\">                    <span class=\"type\">int</span> queueId;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        queueId = Integer.parseInt(fileQueueId.getName());</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (NumberFormatException e) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"type\">ConsumeQueue</span> <span class=\"variable\">logic</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConsumeQueue</span>(</span><br><span class=\"line\">                        topic,</span><br><span class=\"line\">                        queueId,</span><br><span class=\"line\">                        StorePathConfigHelper.getStorePathConsumeQueue(<span class=\"built_in\">this</span>.messageStoreConfig.getStorePathRootDir()),</span><br><span class=\"line\">                        <span class=\"built_in\">this</span>.getMessageStoreConfig().getMappedFileSizeConsumeQueue(),</span><br><span class=\"line\">                        <span class=\"built_in\">this</span>);</span><br><span class=\"line\">                    <span class=\"built_in\">this</span>.putConsumeQueue(topic, queueId, logic);</span><br><span class=\"line\">                    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;load logics queue all over, OK&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>load</code>完之后会通过<code>recover</code>将数据初始化到堆外内存中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">recover</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> List&lt;MappedFile&gt; mappedFiles = <span class=\"built_in\">this</span>.mappedFileQueue.getMappedFiles();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mappedFiles.isEmpty()) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> mappedFiles.size() - <span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            index = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">mappedFileSizeLogics</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.mappedFileSize;</span><br><span class=\"line\">        <span class=\"type\">MappedFile</span> <span class=\"variable\">mappedFile</span> <span class=\"operator\">=</span> mappedFiles.get(index);</span><br><span class=\"line\">        <span class=\"type\">ByteBuffer</span> <span class=\"variable\">byteBuffer</span> <span class=\"operator\">=</span> mappedFile.sliceByteBuffer();</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">processOffset</span> <span class=\"operator\">=</span> mappedFile.getFileFromOffset();</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">mappedFileOffset</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">maxExtAddr</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; mappedFileSizeLogics; i += CQ_STORE_UNIT_SIZE)          &#123;</span><br><span class=\"line\">                ....<span class=\"comment\">//省略文件读取</span></span><br><span class=\"line\">                <span class=\"comment\">//记录最大物理偏移</span></span><br><span class=\"line\">                <span class=\"built_in\">this</span>.maxPhysicOffset = offset + size;</span><br><span class=\"line\"></span><br><span class=\"line\">                .....</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//记录当前文件的offset</span></span><br><span class=\"line\">        processOffset += mappedFileOffset;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.mappedFileQueue.setFlushedWhere(processOffset);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.mappedFileQueue.setCommittedWhere(processOffset);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.mappedFileQueue.truncateDirtyFiles(processOffset);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isExtReadEnable()) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.consumeQueueExt.recover();</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;Truncate consume queue extend file by max &#123;&#125;&quot;</span>, maxExtAddr);</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.consumeQueueExt.truncateByMaxAddress(maxExtAddr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取消息\"><a href=\"#获取消息\" class=\"headerlink\" title=\"获取消息\"></a>获取消息</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> SelectMappedBufferResult <span class=\"title function_\">getIndexBuffer</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"type\">long</span> startIndex)</span> &#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> <span class=\"variable\">mappedFileSize</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.mappedFileSize;</span><br><span class=\"line\">   <span class=\"comment\">//通过startIndex * 单条消息的大小定位offset</span></span><br><span class=\"line\">   <span class=\"type\">long</span> <span class=\"variable\">offset</span> <span class=\"operator\">=</span> startIndex * CQ_STORE_UNIT_SIZE;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (offset &gt;= <span class=\"built_in\">this</span>.getMinLogicOffset()) &#123;</span><br><span class=\"line\">       <span class=\"type\">MappedFile</span> <span class=\"variable\">mappedFile</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.mappedFileQueue.findMappedFileByOffset(offset);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mappedFile != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"type\">SelectMappedBufferResult</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> mappedFile.selectMappedBuffer((<span class=\"type\">int</span>) (offset % mappedFileSize));</span><br><span class=\"line\">           <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>以上代码对应<code>ConsumeQueue#getIndexBuffer</code>方法，该方法主要通过<code>startIndex</code>来获取消费消息的条目，因为每个条目的大小是固定的 所以只需要根据index*20则可以定位到具体的offset的值，就可以知道具体条目的数据<code>SelectMappedBufferResult</code>也就是开始消费的条目 然后往后消费，具体代码在<code>DefaultMessageStore#getMessages</code>方法中.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">for</span> (; i &lt; bufferConsumeQueue.getSize() &amp;&amp; i &lt; maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">offsetPy</span> <span class=\"operator\">=</span> bufferConsumeQueue.getByteBuffer().getLong();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">sizePy</span> <span class=\"operator\">=</span> bufferConsumeQueue.getByteBuffer().getInt();</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">tagsCode</span> <span class=\"operator\">=</span> bufferConsumeQueue.getByteBuffer().getLong();</span><br><span class=\"line\">    ....</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">SelectMappedBufferResult</span> <span class=\"variable\">selectResult</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.commitLog.getMessage(offsetPy, sizePy);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面已经说过每一个条目中包含<code>commitlogOffset，size,tagCode</code>三个数据，那么<code>commitLog.getMessage(offsetPy, sizePy)</code>获取对应位置上的消息.</p>\n<h3 id=\"根据时间获取消息\"><a href=\"#根据时间获取消息\" class=\"headerlink\" title=\"根据时间获取消息\"></a>根据时间获取消息</h3><p>在<code>ConsumeQueue#getOffsetInQueueByTime</code>中实现了对消息进行时间偏移读取，但是在<code>consumeQueue</code>并没有记录消息的时间，所以避免不了去<code>commitlog</code>中获取对应消息的偏移量，我们看下consumeQueue是如何实现的。</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">getOffsetInQueueByTime</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timestamp)</span> </span>&#123;</span><br><span class=\"line\">    MappedFile mappedFile = <span class=\"keyword\">this</span>.mappedFileQueue.getMappedFileByTime(timestamp);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mappedFile != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> offset = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> low = minLogicOffset &gt; mappedFile.getFileFromOffset() ? (<span class=\"keyword\">int</span>) (minLogicOffset - mappedFile.getFileFromOffset()) : 0;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> high = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> midOffset = <span class=\"number\">-1</span>, targetOffset = <span class=\"number\">-1</span>, leftOffset = <span class=\"number\">-1</span>, rightOffset = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> leftIndexValue = <span class=\"number\">-1</span>L, rightIndexValue = <span class=\"number\">-1</span>L;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> minPhysicOffset = <span class=\"keyword\">this</span>.defaultMessageStore.getMinPhyOffset();</span><br><span class=\"line\">        SelectMappedBufferResult sbr = mappedFile.selectMappedBuffer(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != sbr) &#123;</span><br><span class=\"line\">            ByteBuffer byteBuffer = sbr.getByteBuffer();</span><br><span class=\"line\">            high = byteBuffer.limit() - CQ_STORE_UNIT_SIZE;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (high &gt;= low) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//通过最小偏移量和最大偏移量获取中位偏移量</span></span><br><span class=\"line\">                    midOffset = (low + high) / (<span class=\"number\">2</span> * CQ_STORE_UNIT_SIZE) * CQ_STORE_UNIT_SIZE;</span><br><span class=\"line\">                    <span class=\"comment\">//...省略数据读取</span></span><br><span class=\"line\">                    <span class=\"comment\">//从commitlog中获取当前位置消息的时间</span></span><br><span class=\"line\">                    <span class=\"keyword\">long</span> storeTime =</span><br><span class=\"line\">                        <span class=\"keyword\">this</span>.defaultMessageStore.getCommitLog().pickupStoreTimestamp(phyOffset, size);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (storeTime &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">                    &#125; <span class=\"function\"><span class=\"keyword\">else</span> <span class=\"title\">if</span> <span class=\"params\">(storeTime == timestamp)</span> </span>&#123;</span><br><span class=\"line\">                        targetOffset = midOffset;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125; <span class=\"function\"><span class=\"keyword\">else</span> <span class=\"title\">if</span> <span class=\"params\">(storeTime &gt; timestamp)</span> </span>&#123;</span><br><span class=\"line\">                         <span class=\"comment\">// 如果消息大于当前中位消息时间 则再往前进行二分查找</span></span><br><span class=\"line\">                        high = midOffset - CQ_STORE_UNIT_SIZE;</span><br><span class=\"line\">                        rightOffset = midOffset;</span><br><span class=\"line\">                        rightIndexValue = storeTime;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                       <span class=\"comment\">// 如果消息大于当前中位消息时间 则再往后进行二分查找</span></span><br><span class=\"line\">                        low = midOffset + CQ_STORE_UNIT_SIZE;</span><br><span class=\"line\">                        leftOffset = midOffset;</span><br><span class=\"line\">                        leftIndexValue = storeTime;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (targetOffset != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    offset = targetOffset;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (leftIndexValue == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                        offset = rightOffset;</span><br><span class=\"line\">                    &#125; <span class=\"function\"><span class=\"keyword\">else</span> <span class=\"title\">if</span> <span class=\"params\">(rightIndexValue == <span class=\"number\">-1</span>)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                        offset = leftOffset;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        offset =</span><br><span class=\"line\">                            Math.abs(timestamp - leftIndexValue) &gt; Math.abs(timestamp</span><br><span class=\"line\">                                - rightIndexValue) ? rightOffset : leftOffset;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> (mappedFile.getFileFromOffset() + offset) / CQ_STORE_UNIT_SIZE;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                sbr.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>通过上面我们可以看出 rocketmq通过二分查找<code>consumeQueue</code>的方式去<code>commitlog</code>中检索对应消息的时间点进行比较。</p>\n<h2 id=\"IndexFile\"><a href=\"#IndexFile\" class=\"headerlink\" title=\"IndexFile\"></a>IndexFile</h2><h3 id=\"作用-1\"><a href=\"#作用-1\" class=\"headerlink\" title=\"作用\"></a>作用</h3><p>IndexFile 文件存储的是 包含<code>Key</code>的消息，当生产者生产消息到Broker的时候，Broker接收消息的是发现消息包含Key的时候 会将对应消息的索引记录在IndexFile中,只记录包含<code>Key</code>的消息是因为 RocketMq 可以通过制定key查询消息</p>\n<p>IndexFile 文件名称是已创建文件时间的时间戳命令 <code>20210901183407523</code></p>\n<h3 id=\"数据格式-2\"><a href=\"#数据格式-2\" class=\"headerlink\" title=\"数据格式\"></a>数据格式</h3><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">┌────────────────────┬────────────────────┬──────────────────────┐</span><br><span class=\"line\">│                    │                    │                      │</span><br><span class=\"line\">│    Header          │       Slots        │        Indexes       │</span><br><span class=\"line\">│                    │                    │                      │</span><br><span class=\"line\">│    <span class=\"number\">40</span> <span class=\"type\">byte</span>         │    <span class=\"number\">4</span> <span class=\"type\">byte</span> * <span class=\"number\">500</span>w   │   <span class=\"number\">20</span> <span class=\"type\">byte</span> * <span class=\"number\">2000</span>w    │</span><br><span class=\"line\">│                    │                    │                      │</span><br><span class=\"line\">└────────────────────┴────────────────────┴──────────────────────┘</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Header\"><a href=\"#Header\" class=\"headerlink\" title=\"Header\"></a>Header</h3><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>beginTimestamp</td>\n<td>第一条消息时间戳</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>endTimestampIndex</td>\n<td>最后一条消息时间戳</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>beginPhyOffset</td>\n<td>在commitlog中开始的offset</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>endPhyOffset</td>\n<td>在commitlog中结束的offset</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>hashSlotCount</td>\n<td>已使用的SlotCount</td>\n<td>Int</td>\n</tr>\n<tr>\n<td>IndexCount</td>\n<td>索引单元的数量</td>\n<td>Int</td>\n</tr>\n</tbody></table>\n<p>索引文件中的Header 主要包含以上几个部分 所占用大小就等于 <code>8 + 8 + 8 + 8 + 4 + 4 = 40</code>个字节，在RocketMQ源码中我们可以看到<code>IndexHeader</code>类中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">beginTimestampIndex</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">endTimestampIndex</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">beginPhyoffsetIndex</span> <span class=\"operator\">=</span> <span class=\"number\">16</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">endPhyoffsetIndex</span> <span class=\"operator\">=</span> <span class=\"number\">24</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">hashSlotcountIndex</span> <span class=\"operator\">=</span> <span class=\"number\">32</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">indexCountIndex</span> <span class=\"operator\">=</span> <span class=\"number\">36</span>;</span><br><span class=\"line\">....</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">beginTimestamp</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">endTimestamp</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">beginPhyOffset</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">endPhyOffset</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">AtomicInteger</span> <span class=\"variable\">hashSlotCount</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">AtomicInteger</span> <span class=\"variable\">indexCount</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Slots\"><a href=\"#Slots\" class=\"headerlink\" title=\"Slots\"></a>Slots</h3><p>Slot是槽位,每一个槽位占用4个字节也就是Int值 表示的是索引单元列表(Indexes)中当前槽位 key最新的索引值(这句话可能有点绕 通过代码和图来理解下)，在<code>IndexFile</code>类中的实现</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">IndexFile</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"type\">String</span> fileName, <span class=\"keyword\">final</span> <span class=\"type\">int</span> hashSlotNum, <span class=\"keyword\">final</span> <span class=\"type\">int</span> indexNum,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">   <span class=\"keyword\">final</span> <span class=\"type\">long</span> endPhyOffset, <span class=\"keyword\">final</span> <span class=\"type\">long</span> endTimestamp)</span> throws IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> fileTotalSize =</span><br><span class=\"line\">   IndexHeader.INDEX_HEADER_SIZE + (hashSlotNum * hashSlotSize) + (indexNum * indexSize);</span><br><span class=\"line\">   </span><br><span class=\"line\"> ....</span><br><span class=\"line\"> <span class=\"keyword\">this</span>.hashSlotNum = hashSlotNum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">int</span> maxHashSlotNum = <span class=\"number\">5000000</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">int</span> maxIndexNum = <span class=\"number\">5000000</span> * <span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure>\n\n<p>fileTotalSize<code>表示整个IndexFile文件大小是固定的，</code>maxHashSlotNum<code>表示最多槽位为500万个,</code>maxIndexNum<code>表示最多索引单元为 2000万个 那么可以知道文件大小为</code>500万*4 + 2000万 * 20 + 40</p>\n<p>那么每一个key如何计算所在的槽位呢？ 是通过key的hashcode 取模 500万</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int keyHash <span class=\"operator\">=</span> indexKeyHashMethod(key)<span class=\"comment\">;</span></span><br><span class=\"line\">int slotPos <span class=\"operator\">=</span> keyHash % this.hashSlotNum<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>slotPos</code>就表示当前消息key所在的槽位索引</p>\n<p>每一个槽位中的值 都是<strong>最新</strong>索引单元 所对应<code>Indexes</code>中的索引的Position 对应源码中如下</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// indexHead也就是40B 加上槽位索引*4B 获取当前槽位在文件中的具体position</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos<span class=\"operator\"> * </span>hashSlotSize;</span><br><span class=\"line\"><span class=\"comment\">// 通过position 取得对应槽位上的值</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> slotValue = this.mappedByteBuffer.get<span class=\"constructor\">Int(<span class=\"params\">absSlotPos</span>)</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (slotValue &lt;= invalidIndex<span class=\"operator\"> || </span>slotValue &gt; this.indexHeader.get<span class=\"constructor\">IndexCount()</span>) &#123;</span><br><span class=\"line\">    slotValue = invalidIndex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">....</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置槽位position的最新索引值为当前索引单元的count 也就是插入进去的索引单元在 indexes中的索引</span></span><br><span class=\"line\">this.mappedByteBuffer.put<span class=\"constructor\">Int(<span class=\"params\">absSlotPos</span>, <span class=\"params\">this</span>.<span class=\"params\">indexHeader</span>.<span class=\"params\">getIndexCount</span>()</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Indexes\"><a href=\"#Indexes\" class=\"headerlink\" title=\"Indexes\"></a>Indexes</h3><p>index 索引单元存储 数据结构如下</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>keyHash</td>\n<td>消息key的hashCode</td>\n<td>Int</td>\n</tr>\n<tr>\n<td>phyOffset</td>\n<td>消息在Commitlog文件中的偏移量</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>timeDiff</td>\n<td>当前消息和文件起始消息的时间差 精确到秒</td>\n<td>Int</td>\n</tr>\n<tr>\n<td>preSlotValue</td>\n<td>上一个索引单元对应的下标值（方便理解）</td>\n<td>Int</td>\n</tr>\n</tbody></table>\n<p>所以每一个索引单元占用的大小为 <code>4+8+4+4 = 20B</code></p>\n<h3 id=\"通过Key查询消息的流程\"><a href=\"#通过Key查询消息的流程\" class=\"headerlink\" title=\"通过Key查询消息的流程\"></a>通过Key查询消息的流程</h3><ol>\n<li>获取对应Key的HashCode</li>\n<li>通过HashCode找到槽位</li>\n<li>通过槽位获取最新的Index索引</li>\n<li>通过索引中的HasCode比对 依次向上查找 这里还可以通过时间筛选</li>\n<li>将对应符合条件的Index单元中的 commitLog的offset记录 查询对应消息</li>\n</ol>\n","site":{"data":{"footer":"<script color=\"0,0,255\" opacity=\"0.5\" zIndex=\"-1\" count=\"99\" src=\"https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js\"></script>\n"}},"length":4100,"excerpt":"","more":"<h2 id=\"CommitLog\"><a href=\"#CommitLog\" class=\"headerlink\" title=\"CommitLog\"></a>CommitLog</h2><p>主要存储文件以及目录包含以下几个</p>\n<ol>\n<li><strong>abort</strong> 用来记录整个broker是否为安全关闭的一个状态标识 在运行起来的时候会创建abort文件 安全关闭的情况下会删除 abort文件</li>\n<li><strong>checkpoint</strong> 记录 commitlog，consumequeue, index 文件最后刷盘时间戳</li>\n<li><strong>commitlog</strong>  存储所有消息的一个文件夹 该文件夹下包含当前broker接受的所有消息 下面会详细介绍commitlog存储消息的格式</li>\n<li><strong>config</strong>  broker运行的一些配置文件 以及consumer的消费进度等</li>\n<li><strong>consumequeue</strong>  topic对应消费队列的存储 每一个topic下面为每一个queue创建了一个目录目录名称为queue的id 下面会详细描述consumequeue的结构和作用</li>\n<li><strong>index</strong> 消息索引 存储的是带有key的Message 下面为详细描述Index文件的作用以及结构</li>\n<li><strong>lock</strong> 运行期间用到的全局锁</li>\n</ol>\n<h3 id=\"写入方式\"><a href=\"#写入方式\" class=\"headerlink\" title=\"写入方式\"></a>写入方式</h3><p>在<code>MessageStore</code>的接口定义了几种PutMessage的方式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 异步写入返回CompletableFuture</span></span><br><span class=\"line\"><span class=\"keyword\">default</span> CompletableFuture&lt;PutMessageResult&gt; <span class=\"title function_\">asyncPutMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageExtBrokerInner msg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> CompletableFuture.completedFuture(putMessage(msg));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 异步批量写入 返回CompletableFuture</span></span><br><span class=\"line\"><span class=\"keyword\">default</span> CompletableFuture&lt;PutMessageResult&gt; <span class=\"title function_\">asyncPutMessages</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageExtBatch messageExtBatch)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> CompletableFuture.completedFuture(putMessages(messageExtBatch));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同步写入直接返回PutMessageResult</span></span><br><span class=\"line\">PutMessageResult <span class=\"title function_\">putMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageExtBrokerInner msg)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//同步批量写入PutMessageResult</span></span><br><span class=\"line\">PutMessageResult <span class=\"title function_\">putMessages</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageExtBatch messageExtBatch)</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"数据格式\"><a href=\"#数据格式\" class=\"headerlink\" title=\"数据格式\"></a>数据格式</h3><p>commitlog目录下存储的就是对应具体消息，commitlog文件名称是由20个十进制的数字组成的 表示当前commitlog文件起始的文件偏移量 第一个文件肯定是<code>00000000000000000000</code>，每一个commitlog文件大小都是固定的1G，但是对应的内容是<strong>小余等于1G</strong>，消息为一个整体单元不可分割所以是小余等于1G的。</p>\n<table>\n<thead>\n<tr>\n<th><strong>属性</strong></th>\n<th><strong>描述</strong></th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>msgLen</td>\n<td>消息长度</td>\n<td>Int</td>\n</tr>\n<tr>\n<td>bodyCrc</td>\n<td>checksum 校验</td>\n<td>Int</td>\n</tr>\n<tr>\n<td>queueId</td>\n<td>队列id</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>flag</td>\n<td>用户自定义</td>\n<td>Int</td>\n</tr>\n<tr>\n<td>queueOffset</td>\n<td>队列偏移量</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>physicalOffset</td>\n<td>磁盘文件偏移量</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>sysFlag</td>\n<td>用来计算FilterType和事务状态</td>\n<td>Int</td>\n</tr>\n<tr>\n<td>bornHostTimestamp</td>\n<td>消息创建时间</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>bornHost</td>\n<td>生产者Host, ipv4: IP(4)+Port(4) 8 , Ipv6: IP(16)+Port(4)</td>\n<td>8 or 20</td>\n</tr>\n<tr>\n<td>storeTimeStamp</td>\n<td>消息存储时间</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>storehostAddressLength</td>\n<td>broker地址</td>\n<td>8 or 20</td>\n</tr>\n<tr>\n<td>reconsumeTimes</td>\n<td>回收时间</td>\n<td>Int</td>\n</tr>\n<tr>\n<td>preparedTransactionOffset</td>\n<td>预处理事务消息的偏移量</td>\n<td>Int</td>\n</tr>\n<tr>\n<td>bodyLength</td>\n<td>消息体长度</td>\n<td>Int</td>\n</tr>\n<tr>\n<td>body</td>\n<td>消息体</td>\n<td>bodyLength</td>\n</tr>\n<tr>\n<td>topicLength</td>\n<td>消息归属Topic</td>\n<td></td>\n</tr>\n<tr>\n<td>propertiesLength</td>\n<td>配置信息</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"写入机制\"><a href=\"#写入机制\" class=\"headerlink\" title=\"写入机制\"></a>写入机制</h3><h4 id=\"发送消息请求\"><a href=\"#发送消息请求\" class=\"headerlink\" title=\"发送消息请求\"></a>发送消息请求</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 解析消息头 包含消息生产者发送的一些信息以及topic和队列信息</span></span><br><span class=\"line\"><span class=\"type\">SendMessageRequestHeader</span> <span class=\"variable\">requestHeader</span> <span class=\"operator\">=</span> parseRequestHeader(request);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (requestHeader == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> CompletableFuture.completedFuture(<span class=\"literal\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 消息的上下文 可以用于跟踪消息trace 基本上就是reqeustHeader中的一些信息</span></span><br><span class=\"line\">mqtraceContext = buildMsgContext(ctx, requestHeader);</span><br><span class=\"line\"><span class=\"comment\">//注册的一些消息hook</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.executeSendMessageHookBefore(ctx, request, mqtraceContext);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (requestHeader.isBatch()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//批量消息</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.asyncSendBatchMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//单条消息</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.asyncSendMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> CompletableFuture&lt;RemotingCommand&gt; <span class=\"title function_\">asyncSendMessage</span><span class=\"params\">(ChannelHandlerContext ctx, RemotingCommand request,</span></span><br><span class=\"line\"><span class=\"params\">                                                            SendMessageContext mqtraceContext,</span></span><br><span class=\"line\"><span class=\"params\">                                                            SendMessageRequestHeader requestHeader)</span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"type\">int</span> <span class=\"variable\">queueIdInt</span> <span class=\"operator\">=</span> requestHeader.getQueueId();</span><br><span class=\"line\">   <span class=\"comment\">//获取topic的配置信息</span></span><br><span class=\"line\">   <span class=\"type\">TopicConfig</span> <span class=\"variable\">topicConfig</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</span><br><span class=\"line\">    ....</span><br><span class=\"line\">    <span class=\"type\">MessageExtBrokerInner</span> <span class=\"variable\">msgInner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageExtBrokerInner</span>();</span><br><span class=\"line\">    ... <span class=\"comment\">//省去填充Message数据部分</span></span><br><span class=\"line\"></span><br><span class=\"line\">    CompletableFuture&lt;PutMessageResult&gt; putMessageResult = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">transFlag</span> <span class=\"operator\">=</span> origProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (transFlag != <span class=\"literal\">null</span> &amp;&amp; Boolean.parseBoolean(transFlag)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//事物消息存储</span></span><br><span class=\"line\">        putMessageResult = <span class=\"built_in\">this</span>.brokerController.getTransactionalMessageService().asyncPrepareMessage(msgInner);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//普通消息存储</span></span><br><span class=\"line\">        putMessageResult = <span class=\"built_in\">this</span>.brokerController.getMessageStore().asyncPutMessage(msgInner);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> handlePutMessageResultFuture(putMessageResult, response, request, msgInner, responseHeader, mqtraceContext, ctx, queueIdInt);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>getMessageStore</code>的实现默认为<code>DefaultMessageStore</code> 最后实现消息存储的为<code>CommitLog</code>或<code>DLedgerCommitLog</code>，我们主要看下<code>CommitLog</code>的实现。</p>\n<h4 id=\"处理消息存储\"><a href=\"#处理消息存储\" class=\"headerlink\" title=\"处理消息存储\"></a>处理消息存储</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> CompletableFuture&lt;PutMessageResult&gt; <span class=\"title function_\">asyncPutMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageExtBrokerInner msg)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     ... <span class=\"comment\">//省略判断以及填充逻辑</span></span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"comment\">//获取消息的编码器</span></span><br><span class=\"line\">    <span class=\"type\">PutMessageThreadLocal</span> <span class=\"variable\">putMessageThreadLocal</span> <span class=\"operator\">=</span>  <span class=\"built_in\">this</span>.putMessageThreadLocal.get();</span><br><span class=\"line\">    <span class=\"comment\">//将消息进行编码 对应实现在`MessageExtEncoder`中 主要将上面说的消息结构 编码成bytebuffer</span></span><br><span class=\"line\">    <span class=\"type\">PutMessageResult</span> <span class=\"variable\">encodeResult</span> <span class=\"operator\">=</span> putMessageThreadLocal.getEncoder().encode(msg);</span><br><span class=\"line\">    <span class=\"comment\">//将编码结果赋值给msg的EncodeBuffer</span></span><br><span class=\"line\">   msg.setEncodedBuff(putMessageThreadLocal.getEncoder().encoderBuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//写入锁 这里的锁可以通过配置文件使用 CAS实现的自旋锁 或者ReentrantLock</span></span><br><span class=\"line\">    putMessageLock.lock(); </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取对应的MappedFile 最后一个 没有即为空</span></span><br><span class=\"line\">        <span class=\"type\">MappedFile</span> <span class=\"variable\">mappedFile</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.mappedFileQueue.getLastMappedFile();</span><br><span class=\"line\">           ....</span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> == mappedFile || mappedFile.isFull()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//当mappedfile为空 或者已经写满了 则新创建一个mappedfile</span></span><br><span class=\"line\">            mappedFile = <span class=\"built_in\">this</span>.mappedFileQueue.getLastMappedFile(<span class=\"number\">0</span>); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         .....</span><br><span class=\"line\">         <span class=\"comment\">// 将消息追加到mappedFile中</span></span><br><span class=\"line\">        result = mappedFile.appendMessage(msg, <span class=\"built_in\">this</span>.appendMessageCallback, putMessageContext);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (result.getStatus()) &#123;</span><br><span class=\"line\">           <span class=\"comment\">//....</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> END_OF_FILE:</span><br><span class=\"line\">                unlockMappedFile = mappedFile;</span><br><span class=\"line\">                <span class=\"comment\">// 写入文件过大 超过整个mappedFile的大小 新创建文件再次写入 commitlog文件尾部留有默认长度为 8个字节</span></span><br><span class=\"line\">                mappedFile = <span class=\"built_in\">this</span>.mappedFileQueue.getLastMappedFile(<span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"comment\">//....</span></span><br><span class=\"line\">                result = mappedFile.appendMessage(msg, <span class=\"built_in\">this</span>.appendMessageCallback, putMessageContext);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        elapsedTimeInLock = <span class=\"built_in\">this</span>.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;</span><br><span class=\"line\">        beginTimeInLock = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        putMessageLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>通过上面代码我们可以看出来 文件创建的时机有两种，一种是第一次消息存储 内存中没有对应的<code>mappedFile</code>文件 则通过<code>mappedFileQueue.getLastMappedFile(0)</code>方式创建新的mappedFile文件， 第二种是当前最新的<code>mappedFile</code>已经无法写入新的消息了 则创建新的<code>mappedFile</code>文件.</p>\n<h4 id=\"MappedFile文件创建\"><a href=\"#MappedFile文件创建\" class=\"headerlink\" title=\"MappedFile文件创建\"></a>MappedFile文件创建</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mappedFileLast != <span class=\"literal\">null</span> &amp;&amp; mappedFileLast.isFull()) &#123;</span><br><span class=\"line\">    createOffset = mappedFileLast.getFileFromOffset() + <span class=\"built_in\">this</span>.mappedFileSize;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (createOffset != -<span class=\"number\">1</span> &amp;&amp; needCreate) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// nextFilePath 就是最后一个文件起始的offset + 最后一个文件的大小</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">nextFilePath</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.storePath + File.separator + UtilAll.offset2FileName(createOffset);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">nextNextFilePath</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.storePath + File.separator</span><br><span class=\"line\">        + UtilAll.offset2FileName(createOffset + <span class=\"built_in\">this</span>.mappedFileSize);</span><br><span class=\"line\">    <span class=\"type\">MappedFile</span> <span class=\"variable\">mappedFile</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    ..... <span class=\"comment\">//省略部分逻辑</span></span><br><span class=\"line\">       mappedFile = <span class=\"built_in\">this</span>.allocateMappedFileService.putRequestAndReturnMappedFile(nextFilePath,</span><br><span class=\"line\">            nextNextFilePath, <span class=\"built_in\">this</span>.mappedFileSize)</span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Only interrupted by the external thread, will return false</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">mmapOperation</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">isSuccess</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"type\">AllocateRequest</span> <span class=\"variable\">req</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从队列中获取数据</span></span><br><span class=\"line\">        req = <span class=\"built_in\">this</span>.requestQueue.take();</span><br><span class=\"line\">       ...<span class=\"comment\">//省略部分过程</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.getMappedFile() == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">beginTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">            MappedFile mappedFile;</span><br><span class=\"line\">           <span class=\"comment\">// 判断是否开启 isTransientStorePoolEnable ，如果开启则使用堆外内存进行写入数据，最后从堆外内存中 commit 到 FileChannel 中。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (messageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    mappedFile = ServiceLoader.load(MappedFile.class).iterator().next();</span><br><span class=\"line\">                    mappedFile.init(req.getFilePath(), req.getFileSize(), messageStore.getTransientStorePool());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123;</span><br><span class=\"line\">                    log.warn(<span class=\"string\">&quot;Use default implementation.&quot;</span>);</span><br><span class=\"line\">                    mappedFile = <span class=\"keyword\">new</span> <span class=\"title class_\">MappedFile</span>(req.getFilePath(), req.getFileSize(), messageStore.getTransientStorePool());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//使用mmap(RandomAccessFile#channel#map方法创建mappedByteBuffer)的方式创建MappedFile</span></span><br><span class=\"line\">                mappedFile = <span class=\"keyword\">new</span> <span class=\"title class_\">MappedFile</span>(req.getFilePath(), req.getFileSize());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">elapsedTime</span> <span class=\"operator\">=</span> UtilAll.computeElapsedTimeMilliseconds(beginTime);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elapsedTime &gt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">queueSize</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.requestQueue.size();</span><br><span class=\"line\">                log.warn(<span class=\"string\">&quot;create mappedFile spent time(ms) &quot;</span> + elapsedTime + <span class=\"string\">&quot; queue size &quot;</span> + queueSize</span><br><span class=\"line\">                    + <span class=\"string\">&quot; &quot;</span> + req.getFilePath() + <span class=\"string\">&quot; &quot;</span> + req.getFileSize());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断文件大小是否大于等于1G只有commitlog才是1G文件 这里其实就是判断是否为 commitlog文件 数据预热 填充对应pagecache的数据 将mmap的数据内存映射提前准备好</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mappedFile.getFileSize() &gt;= <span class=\"built_in\">this</span>.messageStore.getMessageStoreConfig()</span><br><span class=\"line\">                .getMappedFileSizeCommitLog()</span><br><span class=\"line\">                &amp;&amp;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.messageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;</span><br><span class=\"line\">                mappedFile.warmMappedFile(<span class=\"built_in\">this</span>.messageStore.getMessageStoreConfig().getFlushDiskType(),</span><br><span class=\"line\">                    <span class=\"built_in\">this</span>.messageStore.getMessageStoreConfig().getFlushLeastPagesWhenWarmMapedFile());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            req.setMappedFile(mappedFile);</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.hasException = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            isSuccess = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    ....</span><br></pre></td></tr></table></figure>\n\n<p>这里有几个关键点需要说明下 <code>isTransientStorePoolEnable</code>以及 <code>warmMappedFile</code>方法</p>\n<p><strong>isTransientStorePoolEnable</strong><br>这个必须要在异步刷盘而且为master节点上才能开启, 主要是将数据写入到堆外内存中 然后通过批量commit写入到FileChannel中 这会影响到 复制到Slave节点，复制到Slave节点的数据都是已经commit的数据才会复制，所以可能会导致slave节点的数据有延迟 这个延迟受<code>commitIntervalCommitLog</code>,<code>commitCommitLogThoroughInterval</code> 默认为<code>200ms</code>配置影响</p>\n<h3 id=\"文件过期时间\"><a href=\"#文件过期时间\" class=\"headerlink\" title=\"文件过期时间\"></a>文件过期时间</h3><p>消息是被顺序存储在commitlog文件中的，commitlog中因为每条消息的大小是不固定的 所以消息清理是按照时间单位进行清理的</p>\n<p><code>DefaultMessageStore</code>中会创建一个schedule 每10s中检查一次过期文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        DefaultMessageStore.<span class=\"built_in\">this</span>.cleanFilesPeriodically();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span> * <span class=\"number\">60</span>, <span class=\"built_in\">this</span>.messageStoreConfig.getCleanResourceInterval(), TimeUnit.MILLISECONDS);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>清理文件包含<code>commitLog</code>和<code>consumeQueue</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">cleanFilesPeriodically</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.cleanCommitLogService.run();</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.cleanConsumeQueueService.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>commitlog</code>中判断删除条件如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">deleteExpiredFiles</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">deleteCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 配置文件中的过期时间 小时为单位</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">fileReservedTime</span> <span class=\"operator\">=</span> DefaultMessageStore.<span class=\"built_in\">this</span>.getMessageStoreConfig().getFileReservedTime();</span><br><span class=\"line\">    </span><br><span class=\"line\">     ....</span><br><span class=\"line\">     <span class=\"comment\">//清理时间达到 默认为凌晨4点 deleteWhen</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">timeup</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.isTimeToDelete();</span><br><span class=\"line\">    <span class=\"comment\">// 磁盘空间占用率 默认为75%</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">spacefull</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.isSpaceToDelete();</span><br><span class=\"line\">    <span class=\"comment\">// 手动删除</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">manualDelete</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.manualDeleteFileSeveralTimes &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timeup || spacefull || manualDelete) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (manualDelete)</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.manualDeleteFileSeveralTimes--;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">cleanAtOnce</span> <span class=\"operator\">=</span> DefaultMessageStore.<span class=\"built_in\">this</span>.getMessageStoreConfig().isCleanFileForciblyEnable() &amp;&amp; <span class=\"built_in\">this</span>.cleanImmediately;</span><br><span class=\"line\"></span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;begin to delete before &#123;&#125; hours file. timeup: &#123;&#125; spacefull: &#123;&#125; manualDeleteFileSeveralTimes: &#123;&#125; cleanAtOnce: &#123;&#125;&quot;</span>,</span><br><span class=\"line\">            fileReservedTime,</span><br><span class=\"line\">            timeup,</span><br><span class=\"line\">            spacefull,</span><br><span class=\"line\">            manualDeleteFileSeveralTimes,</span><br><span class=\"line\">            cleanAtOnce);</span><br><span class=\"line\"></span><br><span class=\"line\">        fileReservedTime *= <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        deleteCount = DefaultMessageStore.<span class=\"built_in\">this</span>.commitLog.deleteExpiredFile(fileReservedTime, deletePhysicFilesInterval,</span><br><span class=\"line\">            destroyMapedFileIntervalForcibly, cleanAtOnce);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (deleteCount &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (spacefull) &#123;</span><br><span class=\"line\">            log.warn(<span class=\"string\">&quot;disk space will be full soon, but delete file failed.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>默认过期时间为72小时也就是3天，除了我们自动清理，下面几种情况也会自动清理 无论文件是否被消费过都会被清理</p>\n<p>1、文件过期并且达到清理时间 默认是凌晨4点，自动清理过期时间<br>2、文件过期 磁盘空间占用率超过75%后，无论是否到达清理时间 都会自动清理过期时间<br>3、磁盘占用率达到清理阈值 默认85%后，按照设定好的清理规则(默认是时间最早的)清理文件，无论是否过期<br>4、磁盘占用率达到90%后，broker拒绝消息写入</p>\n<h2 id=\"ConsumeQueue\"><a href=\"#ConsumeQueue\" class=\"headerlink\" title=\"ConsumeQueue\"></a>ConsumeQueue</h2><h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><p>Rocketmq是通过订阅Topic来消费消息的，但是因为<code>commitlog</code>是不区分topic存储消息的，如果消费者通过遍历commitlog去消费消息 那么效率就非常低下了，所以设计了<code>ConsumeQueue</code>用来存储Topic下面每一个队列中消费的offset可以将这里理解为一个队列消息对应的索引文件。</p>\n<h3 id=\"数据格式-1\"><a href=\"#数据格式-1\" class=\"headerlink\" title=\"数据格式\"></a>数据格式</h3><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">┌────────────────────┬─────────────────┬──────────────────┐</span><br><span class=\"line\">│                    │                 │                  │</span><br><span class=\"line\">│  CommitLog offset  │     <span class=\"keyword\">Size</span>        │  Tag hashcode    │</span><br><span class=\"line\">│                    │                 │                  │</span><br><span class=\"line\">│        <span class=\"number\">8</span> <span class=\"keyword\">byte</span>      │    <span class=\"number\">4</span> <span class=\"keyword\">byte</span>       │    <span class=\"number\">8</span> <span class=\"keyword\">byte</span>        │</span><br><span class=\"line\">│                    │                 │                  │</span><br><span class=\"line\">└────────────────────┴─────────────────┴──────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>单条ConsumeQueue固定的大小是占用<code>20</code>个字节，所以每一个Consume的大小都是固定的 Consume单个文件的大小也是固定的 总共是30万条数据。</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> static <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> CQ_STORE_UNIT_SIZE = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">// ConsumeQueue <span class=\"keyword\">file</span> <span class=\"built_in\">size</span>,<span class=\"keyword\">default</span> is <span class=\"number\">30</span>W</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"built_in\">int</span> mappedFileSizeConsumeQueue = <span class=\"number\">300000</span> * ConsumeQueue.CQ_STORE_UNIT_SIZE;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"创建时机\"><a href=\"#创建时机\" class=\"headerlink\" title=\"创建时机\"></a>创建时机</h3><p>创建<code>ConsumeQueue</code>的时机其实是通过查询消息的时候 <code>consumeQueueTable</code>中没有当前<code>topic#queueid</code>的时候就会创建一个对应的的mappedFile文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ConsumeQueue <span class=\"title function_\">findConsumeQueue</span><span class=\"params\">(String topic, <span class=\"type\">int</span> queueId)</span> &#123;</span><br><span class=\"line\">   ....</span><br><span class=\"line\">   <span class=\"type\">ConsumeQueue</span> <span class=\"variable\">logic</span> <span class=\"operator\">=</span> map.get(queueId);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> == logic) &#123;</span><br><span class=\"line\">       <span class=\"comment\">//若当前内存中没有对应topic下的consumequeue 则创建对应的consumequeue</span></span><br><span class=\"line\">       <span class=\"type\">ConsumeQueue</span> <span class=\"variable\">newLogic</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConsumeQueue</span>(</span><br><span class=\"line\">           topic,</span><br><span class=\"line\">           queueId,</span><br><span class=\"line\">           StorePathConfigHelper.getStorePathConsumeQueue(<span class=\"built_in\">this</span>.messageStoreConfig.getStorePathRootDir()),</span><br><span class=\"line\">           <span class=\"built_in\">this</span>.getMessageStoreConfig().getMappedFileSizeConsumeQueue(),</span><br><span class=\"line\">           <span class=\"built_in\">this</span>);</span><br><span class=\"line\">       <span class=\"type\">ConsumeQueue</span> <span class=\"variable\">oldLogic</span> <span class=\"operator\">=</span> map.putIfAbsent(queueId, newLogic);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (oldLogic != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           logic = oldLogic;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           logic = newLogic;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> logic;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>调用<code>findConsumeQueue</code>的位置有很多比如通过Topic和queueId获取某个队列消息的时候会使用到</p>\n<h3 id=\"数据恢复\"><a href=\"#数据恢复\" class=\"headerlink\" title=\"数据恢复\"></a>数据恢复</h3><p>在Broker启动的时候会触发<code>DefaultMessageStore#load</code>的方法将本地磁盘中的数据 load到内存。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">load</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// load Commit Log</span></span><br><span class=\"line\">        result = result &amp;&amp; <span class=\"built_in\">this</span>.commitLog.load();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// load Consume Queue</span></span><br><span class=\"line\">        result = result &amp;&amp; <span class=\"built_in\">this</span>.loadConsumeQueue();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"title function_\">recoverConsumeQueue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">maxPhysicOffset</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ConcurrentMap&lt;Integer, ConsumeQueue&gt; maps : <span class=\"built_in\">this</span>.consumeQueueTable.values()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ConsumeQueue logic : maps.values()) &#123;</span><br><span class=\"line\">            logic.recover();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (logic.getMaxPhysicOffset() &gt; maxPhysicOffset) &#123;</span><br><span class=\"line\">                maxPhysicOffset = logic.getMaxPhysicOffset();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxPhysicOffset;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>可以看到在<code>DefaultMessageStore#load</code>方法有一个方法<code>loadConsumeQueue</code>的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">loadConsumeQueue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">dirLogic</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(StorePathConfigHelper.getStorePathConsumeQueue(<span class=\"built_in\">this</span>.messageStoreConfig.getStorePathRootDir()));</span><br><span class=\"line\">    <span class=\"comment\">//获取Store consumequeue目录下所有子目录 加载进来</span></span><br><span class=\"line\">    File[] fileTopicList = dirLogic.listFiles();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fileTopicList != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (File fileTopic : fileTopicList) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">topic</span> <span class=\"operator\">=</span> fileTopic.getName();</span><br><span class=\"line\"></span><br><span class=\"line\">            File[] fileQueueIdList = fileTopic.listFiles();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fileQueueIdList != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (File fileQueueId : fileQueueIdList) &#123;</span><br><span class=\"line\">                    <span class=\"type\">int</span> queueId;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        queueId = Integer.parseInt(fileQueueId.getName());</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (NumberFormatException e) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"type\">ConsumeQueue</span> <span class=\"variable\">logic</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConsumeQueue</span>(</span><br><span class=\"line\">                        topic,</span><br><span class=\"line\">                        queueId,</span><br><span class=\"line\">                        StorePathConfigHelper.getStorePathConsumeQueue(<span class=\"built_in\">this</span>.messageStoreConfig.getStorePathRootDir()),</span><br><span class=\"line\">                        <span class=\"built_in\">this</span>.getMessageStoreConfig().getMappedFileSizeConsumeQueue(),</span><br><span class=\"line\">                        <span class=\"built_in\">this</span>);</span><br><span class=\"line\">                    <span class=\"built_in\">this</span>.putConsumeQueue(topic, queueId, logic);</span><br><span class=\"line\">                    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;load logics queue all over, OK&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>load</code>完之后会通过<code>recover</code>将数据初始化到堆外内存中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">recover</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> List&lt;MappedFile&gt; mappedFiles = <span class=\"built_in\">this</span>.mappedFileQueue.getMappedFiles();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mappedFiles.isEmpty()) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> mappedFiles.size() - <span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            index = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">mappedFileSizeLogics</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.mappedFileSize;</span><br><span class=\"line\">        <span class=\"type\">MappedFile</span> <span class=\"variable\">mappedFile</span> <span class=\"operator\">=</span> mappedFiles.get(index);</span><br><span class=\"line\">        <span class=\"type\">ByteBuffer</span> <span class=\"variable\">byteBuffer</span> <span class=\"operator\">=</span> mappedFile.sliceByteBuffer();</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">processOffset</span> <span class=\"operator\">=</span> mappedFile.getFileFromOffset();</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">mappedFileOffset</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">maxExtAddr</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; mappedFileSizeLogics; i += CQ_STORE_UNIT_SIZE)          &#123;</span><br><span class=\"line\">                ....<span class=\"comment\">//省略文件读取</span></span><br><span class=\"line\">                <span class=\"comment\">//记录最大物理偏移</span></span><br><span class=\"line\">                <span class=\"built_in\">this</span>.maxPhysicOffset = offset + size;</span><br><span class=\"line\"></span><br><span class=\"line\">                .....</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//记录当前文件的offset</span></span><br><span class=\"line\">        processOffset += mappedFileOffset;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.mappedFileQueue.setFlushedWhere(processOffset);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.mappedFileQueue.setCommittedWhere(processOffset);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.mappedFileQueue.truncateDirtyFiles(processOffset);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isExtReadEnable()) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.consumeQueueExt.recover();</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;Truncate consume queue extend file by max &#123;&#125;&quot;</span>, maxExtAddr);</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.consumeQueueExt.truncateByMaxAddress(maxExtAddr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取消息\"><a href=\"#获取消息\" class=\"headerlink\" title=\"获取消息\"></a>获取消息</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> SelectMappedBufferResult <span class=\"title function_\">getIndexBuffer</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"type\">long</span> startIndex)</span> &#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> <span class=\"variable\">mappedFileSize</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.mappedFileSize;</span><br><span class=\"line\">   <span class=\"comment\">//通过startIndex * 单条消息的大小定位offset</span></span><br><span class=\"line\">   <span class=\"type\">long</span> <span class=\"variable\">offset</span> <span class=\"operator\">=</span> startIndex * CQ_STORE_UNIT_SIZE;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (offset &gt;= <span class=\"built_in\">this</span>.getMinLogicOffset()) &#123;</span><br><span class=\"line\">       <span class=\"type\">MappedFile</span> <span class=\"variable\">mappedFile</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.mappedFileQueue.findMappedFileByOffset(offset);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mappedFile != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"type\">SelectMappedBufferResult</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> mappedFile.selectMappedBuffer((<span class=\"type\">int</span>) (offset % mappedFileSize));</span><br><span class=\"line\">           <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>以上代码对应<code>ConsumeQueue#getIndexBuffer</code>方法，该方法主要通过<code>startIndex</code>来获取消费消息的条目，因为每个条目的大小是固定的 所以只需要根据index*20则可以定位到具体的offset的值，就可以知道具体条目的数据<code>SelectMappedBufferResult</code>也就是开始消费的条目 然后往后消费，具体代码在<code>DefaultMessageStore#getMessages</code>方法中.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">for</span> (; i &lt; bufferConsumeQueue.getSize() &amp;&amp; i &lt; maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">offsetPy</span> <span class=\"operator\">=</span> bufferConsumeQueue.getByteBuffer().getLong();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">sizePy</span> <span class=\"operator\">=</span> bufferConsumeQueue.getByteBuffer().getInt();</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">tagsCode</span> <span class=\"operator\">=</span> bufferConsumeQueue.getByteBuffer().getLong();</span><br><span class=\"line\">    ....</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">SelectMappedBufferResult</span> <span class=\"variable\">selectResult</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.commitLog.getMessage(offsetPy, sizePy);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面已经说过每一个条目中包含<code>commitlogOffset，size,tagCode</code>三个数据，那么<code>commitLog.getMessage(offsetPy, sizePy)</code>获取对应位置上的消息.</p>\n<h3 id=\"根据时间获取消息\"><a href=\"#根据时间获取消息\" class=\"headerlink\" title=\"根据时间获取消息\"></a>根据时间获取消息</h3><p>在<code>ConsumeQueue#getOffsetInQueueByTime</code>中实现了对消息进行时间偏移读取，但是在<code>consumeQueue</code>并没有记录消息的时间，所以避免不了去<code>commitlog</code>中获取对应消息的偏移量，我们看下consumeQueue是如何实现的。</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">getOffsetInQueueByTime</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timestamp)</span> </span>&#123;</span><br><span class=\"line\">    MappedFile mappedFile = <span class=\"keyword\">this</span>.mappedFileQueue.getMappedFileByTime(timestamp);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mappedFile != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> offset = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> low = minLogicOffset &gt; mappedFile.getFileFromOffset() ? (<span class=\"keyword\">int</span>) (minLogicOffset - mappedFile.getFileFromOffset()) : 0;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> high = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> midOffset = <span class=\"number\">-1</span>, targetOffset = <span class=\"number\">-1</span>, leftOffset = <span class=\"number\">-1</span>, rightOffset = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> leftIndexValue = <span class=\"number\">-1</span>L, rightIndexValue = <span class=\"number\">-1</span>L;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> minPhysicOffset = <span class=\"keyword\">this</span>.defaultMessageStore.getMinPhyOffset();</span><br><span class=\"line\">        SelectMappedBufferResult sbr = mappedFile.selectMappedBuffer(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != sbr) &#123;</span><br><span class=\"line\">            ByteBuffer byteBuffer = sbr.getByteBuffer();</span><br><span class=\"line\">            high = byteBuffer.limit() - CQ_STORE_UNIT_SIZE;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (high &gt;= low) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//通过最小偏移量和最大偏移量获取中位偏移量</span></span><br><span class=\"line\">                    midOffset = (low + high) / (<span class=\"number\">2</span> * CQ_STORE_UNIT_SIZE) * CQ_STORE_UNIT_SIZE;</span><br><span class=\"line\">                    <span class=\"comment\">//...省略数据读取</span></span><br><span class=\"line\">                    <span class=\"comment\">//从commitlog中获取当前位置消息的时间</span></span><br><span class=\"line\">                    <span class=\"keyword\">long</span> storeTime =</span><br><span class=\"line\">                        <span class=\"keyword\">this</span>.defaultMessageStore.getCommitLog().pickupStoreTimestamp(phyOffset, size);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (storeTime &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">                    &#125; <span class=\"function\"><span class=\"keyword\">else</span> <span class=\"title\">if</span> <span class=\"params\">(storeTime == timestamp)</span> </span>&#123;</span><br><span class=\"line\">                        targetOffset = midOffset;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125; <span class=\"function\"><span class=\"keyword\">else</span> <span class=\"title\">if</span> <span class=\"params\">(storeTime &gt; timestamp)</span> </span>&#123;</span><br><span class=\"line\">                         <span class=\"comment\">// 如果消息大于当前中位消息时间 则再往前进行二分查找</span></span><br><span class=\"line\">                        high = midOffset - CQ_STORE_UNIT_SIZE;</span><br><span class=\"line\">                        rightOffset = midOffset;</span><br><span class=\"line\">                        rightIndexValue = storeTime;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                       <span class=\"comment\">// 如果消息大于当前中位消息时间 则再往后进行二分查找</span></span><br><span class=\"line\">                        low = midOffset + CQ_STORE_UNIT_SIZE;</span><br><span class=\"line\">                        leftOffset = midOffset;</span><br><span class=\"line\">                        leftIndexValue = storeTime;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (targetOffset != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    offset = targetOffset;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (leftIndexValue == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                        offset = rightOffset;</span><br><span class=\"line\">                    &#125; <span class=\"function\"><span class=\"keyword\">else</span> <span class=\"title\">if</span> <span class=\"params\">(rightIndexValue == <span class=\"number\">-1</span>)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                        offset = leftOffset;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        offset =</span><br><span class=\"line\">                            Math.abs(timestamp - leftIndexValue) &gt; Math.abs(timestamp</span><br><span class=\"line\">                                - rightIndexValue) ? rightOffset : leftOffset;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> (mappedFile.getFileFromOffset() + offset) / CQ_STORE_UNIT_SIZE;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                sbr.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>通过上面我们可以看出 rocketmq通过二分查找<code>consumeQueue</code>的方式去<code>commitlog</code>中检索对应消息的时间点进行比较。</p>\n<h2 id=\"IndexFile\"><a href=\"#IndexFile\" class=\"headerlink\" title=\"IndexFile\"></a>IndexFile</h2><h3 id=\"作用-1\"><a href=\"#作用-1\" class=\"headerlink\" title=\"作用\"></a>作用</h3><p>IndexFile 文件存储的是 包含<code>Key</code>的消息，当生产者生产消息到Broker的时候，Broker接收消息的是发现消息包含Key的时候 会将对应消息的索引记录在IndexFile中,只记录包含<code>Key</code>的消息是因为 RocketMq 可以通过制定key查询消息</p>\n<p>IndexFile 文件名称是已创建文件时间的时间戳命令 <code>20210901183407523</code></p>\n<h3 id=\"数据格式-2\"><a href=\"#数据格式-2\" class=\"headerlink\" title=\"数据格式\"></a>数据格式</h3><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">┌────────────────────┬────────────────────┬──────────────────────┐</span><br><span class=\"line\">│                    │                    │                      │</span><br><span class=\"line\">│    Header          │       Slots        │        Indexes       │</span><br><span class=\"line\">│                    │                    │                      │</span><br><span class=\"line\">│    <span class=\"number\">40</span> <span class=\"type\">byte</span>         │    <span class=\"number\">4</span> <span class=\"type\">byte</span> * <span class=\"number\">500</span>w   │   <span class=\"number\">20</span> <span class=\"type\">byte</span> * <span class=\"number\">2000</span>w    │</span><br><span class=\"line\">│                    │                    │                      │</span><br><span class=\"line\">└────────────────────┴────────────────────┴──────────────────────┘</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Header\"><a href=\"#Header\" class=\"headerlink\" title=\"Header\"></a>Header</h3><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>beginTimestamp</td>\n<td>第一条消息时间戳</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>endTimestampIndex</td>\n<td>最后一条消息时间戳</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>beginPhyOffset</td>\n<td>在commitlog中开始的offset</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>endPhyOffset</td>\n<td>在commitlog中结束的offset</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>hashSlotCount</td>\n<td>已使用的SlotCount</td>\n<td>Int</td>\n</tr>\n<tr>\n<td>IndexCount</td>\n<td>索引单元的数量</td>\n<td>Int</td>\n</tr>\n</tbody></table>\n<p>索引文件中的Header 主要包含以上几个部分 所占用大小就等于 <code>8 + 8 + 8 + 8 + 4 + 4 = 40</code>个字节，在RocketMQ源码中我们可以看到<code>IndexHeader</code>类中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">beginTimestampIndex</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">endTimestampIndex</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">beginPhyoffsetIndex</span> <span class=\"operator\">=</span> <span class=\"number\">16</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">endPhyoffsetIndex</span> <span class=\"operator\">=</span> <span class=\"number\">24</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">hashSlotcountIndex</span> <span class=\"operator\">=</span> <span class=\"number\">32</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">indexCountIndex</span> <span class=\"operator\">=</span> <span class=\"number\">36</span>;</span><br><span class=\"line\">....</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">beginTimestamp</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">endTimestamp</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">beginPhyOffset</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">endPhyOffset</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">AtomicInteger</span> <span class=\"variable\">hashSlotCount</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">AtomicInteger</span> <span class=\"variable\">indexCount</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Slots\"><a href=\"#Slots\" class=\"headerlink\" title=\"Slots\"></a>Slots</h3><p>Slot是槽位,每一个槽位占用4个字节也就是Int值 表示的是索引单元列表(Indexes)中当前槽位 key最新的索引值(这句话可能有点绕 通过代码和图来理解下)，在<code>IndexFile</code>类中的实现</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">IndexFile</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"type\">String</span> fileName, <span class=\"keyword\">final</span> <span class=\"type\">int</span> hashSlotNum, <span class=\"keyword\">final</span> <span class=\"type\">int</span> indexNum,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">   <span class=\"keyword\">final</span> <span class=\"type\">long</span> endPhyOffset, <span class=\"keyword\">final</span> <span class=\"type\">long</span> endTimestamp)</span> throws IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> fileTotalSize =</span><br><span class=\"line\">   IndexHeader.INDEX_HEADER_SIZE + (hashSlotNum * hashSlotSize) + (indexNum * indexSize);</span><br><span class=\"line\">   </span><br><span class=\"line\"> ....</span><br><span class=\"line\"> <span class=\"keyword\">this</span>.hashSlotNum = hashSlotNum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">int</span> maxHashSlotNum = <span class=\"number\">5000000</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">int</span> maxIndexNum = <span class=\"number\">5000000</span> * <span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure>\n\n<p>fileTotalSize<code>表示整个IndexFile文件大小是固定的，</code>maxHashSlotNum<code>表示最多槽位为500万个,</code>maxIndexNum<code>表示最多索引单元为 2000万个 那么可以知道文件大小为</code>500万*4 + 2000万 * 20 + 40</p>\n<p>那么每一个key如何计算所在的槽位呢？ 是通过key的hashcode 取模 500万</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int keyHash <span class=\"operator\">=</span> indexKeyHashMethod(key)<span class=\"comment\">;</span></span><br><span class=\"line\">int slotPos <span class=\"operator\">=</span> keyHash % this.hashSlotNum<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>slotPos</code>就表示当前消息key所在的槽位索引</p>\n<p>每一个槽位中的值 都是<strong>最新</strong>索引单元 所对应<code>Indexes</code>中的索引的Position 对应源码中如下</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// indexHead也就是40B 加上槽位索引*4B 获取当前槽位在文件中的具体position</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos<span class=\"operator\"> * </span>hashSlotSize;</span><br><span class=\"line\"><span class=\"comment\">// 通过position 取得对应槽位上的值</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> slotValue = this.mappedByteBuffer.get<span class=\"constructor\">Int(<span class=\"params\">absSlotPos</span>)</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (slotValue &lt;= invalidIndex<span class=\"operator\"> || </span>slotValue &gt; this.indexHeader.get<span class=\"constructor\">IndexCount()</span>) &#123;</span><br><span class=\"line\">    slotValue = invalidIndex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">....</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置槽位position的最新索引值为当前索引单元的count 也就是插入进去的索引单元在 indexes中的索引</span></span><br><span class=\"line\">this.mappedByteBuffer.put<span class=\"constructor\">Int(<span class=\"params\">absSlotPos</span>, <span class=\"params\">this</span>.<span class=\"params\">indexHeader</span>.<span class=\"params\">getIndexCount</span>()</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Indexes\"><a href=\"#Indexes\" class=\"headerlink\" title=\"Indexes\"></a>Indexes</h3><p>index 索引单元存储 数据结构如下</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>keyHash</td>\n<td>消息key的hashCode</td>\n<td>Int</td>\n</tr>\n<tr>\n<td>phyOffset</td>\n<td>消息在Commitlog文件中的偏移量</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>timeDiff</td>\n<td>当前消息和文件起始消息的时间差 精确到秒</td>\n<td>Int</td>\n</tr>\n<tr>\n<td>preSlotValue</td>\n<td>上一个索引单元对应的下标值（方便理解）</td>\n<td>Int</td>\n</tr>\n</tbody></table>\n<p>所以每一个索引单元占用的大小为 <code>4+8+4+4 = 20B</code></p>\n<h3 id=\"通过Key查询消息的流程\"><a href=\"#通过Key查询消息的流程\" class=\"headerlink\" title=\"通过Key查询消息的流程\"></a>通过Key查询消息的流程</h3><ol>\n<li>获取对应Key的HashCode</li>\n<li>通过HashCode找到槽位</li>\n<li>通过槽位获取最新的Index索引</li>\n<li>通过索引中的HasCode比对 依次向上查找 这里还可以通过时间筛选</li>\n<li>将对应符合条件的Index单元中的 commitLog的offset记录 查询对应消息</li>\n</ol>\n"},{"title":"关于ConfigMap配置更新机制","date":"2022-10-10T16:00:00.000Z","description":"ConfigMap延迟更新机制下的一些解决思路.","author":"Slide","_content":"\n## 背景\n\n工作中遇到部分组件，它们依赖的一些配置需要通过ConfigMap挂载到容器内部，但ConfigMap自动更新存在一定延时，这可能会带来一系列的问题。在不能滚动重建的前提下，会存在例如配置刷新不及时等问题，如果本身组件不支持热加载的话，就需要通过一些自定义任务去做这些事。\n## 原因\n\n### Kubelet\n\nKubelet在每个Node节点都会安装，负责维护该节点上的所有容器，并监视容器的健康状态。同步容器需要的数据，数据可能来自配置文件，也可能来自Etcd。Kubelet通过启动参数--sync-frequency来控制同步的间隔时间。它的默认值是1min，所以更新ConfigMap的内容后，真正容器中的挂载内容变化可能在`0~1min`之后。\n\n\n![indexFile-2](/images/cm.png)\n\n\n在K8s的官方文档中，说明了ConfigMap 既可以通过 Watch 操作实现内容传播（默认形式），也可实现基于 TTL 的缓存，还可以直接经过所有请求重定向到 API 服务器。 因此，从 ConfigMap 被更新的那一刻算起，到新的主键被投射到 Pod 中去，这一时间跨度可能与 Kubelet 的同步周期加上高速缓存的传播延迟相等。 这里的传播延迟取决于所选的高速缓存类型，分别对应 Watch 操作的传播延迟、高速缓存的 TTL 时长或者 0。\n\n基于此总延迟时间：\n\n```\nTotalDelayTime = kubelet sync-frequency + watch manager delay\n```\n\n## 解决\n\n### 应用本身监听本地配置文件\n\n在RocketMQ中，Acl的更新就通过内核监听配置文件从而实现了热更新。在RocketMQ On K8s中，一种比较常见的做法是，将Acl的配置文件通过ConfigMap挂载，但由于本身ConfigMap的延迟，在用户体验上来说，并不是一种很好的解决方案。更好的做法是通过内核提供的API接口完成Acl配置的更新。\n\n### 使用 Sidecar 来监听本地配置文件变更\n\n这也是业内比较标准的做法。Prometheus 的 Helm Chart 中使用的就是这种方式。这里有一个很实用的镜像叫做 [configmap-reload](https://github.com/jimmidyson/configmap-reload)，它会去 watch 本地文件的变更，并在发生变更时通过 HTTP 调用通知应用进行热更新。同时Emqx Operator对于插件的加载也使用了这种方式。[emqx-operator](https://github.com/emqx/emqx-operator/blob/main/sidecar/reloader/main.go)\n\n\n\n## Reference\n[ConfigMaps | Kubernetes](https://kubernetes.io/docs/concepts/configuration/configmap/)\n\n[Kubernetes Pod 中的 ConfigMap 配置更新 (aleiwu.com)](https://aleiwu.com/post/configmap-hotreload/#热更新二-使用-sidecar-来监听本地配置文件变更)","source":"_posts/configmap.md","raw":"---\ntitle: 关于ConfigMap配置更新机制\ndate: 2022/10/11\ndescription: ConfigMap延迟更新机制下的一些解决思路.\ntag: Kubernetes\nauthor: Slide\ncategories: Kubernetes\n---\n\n## 背景\n\n工作中遇到部分组件，它们依赖的一些配置需要通过ConfigMap挂载到容器内部，但ConfigMap自动更新存在一定延时，这可能会带来一系列的问题。在不能滚动重建的前提下，会存在例如配置刷新不及时等问题，如果本身组件不支持热加载的话，就需要通过一些自定义任务去做这些事。\n## 原因\n\n### Kubelet\n\nKubelet在每个Node节点都会安装，负责维护该节点上的所有容器，并监视容器的健康状态。同步容器需要的数据，数据可能来自配置文件，也可能来自Etcd。Kubelet通过启动参数--sync-frequency来控制同步的间隔时间。它的默认值是1min，所以更新ConfigMap的内容后，真正容器中的挂载内容变化可能在`0~1min`之后。\n\n\n![indexFile-2](/images/cm.png)\n\n\n在K8s的官方文档中，说明了ConfigMap 既可以通过 Watch 操作实现内容传播（默认形式），也可实现基于 TTL 的缓存，还可以直接经过所有请求重定向到 API 服务器。 因此，从 ConfigMap 被更新的那一刻算起，到新的主键被投射到 Pod 中去，这一时间跨度可能与 Kubelet 的同步周期加上高速缓存的传播延迟相等。 这里的传播延迟取决于所选的高速缓存类型，分别对应 Watch 操作的传播延迟、高速缓存的 TTL 时长或者 0。\n\n基于此总延迟时间：\n\n```\nTotalDelayTime = kubelet sync-frequency + watch manager delay\n```\n\n## 解决\n\n### 应用本身监听本地配置文件\n\n在RocketMQ中，Acl的更新就通过内核监听配置文件从而实现了热更新。在RocketMQ On K8s中，一种比较常见的做法是，将Acl的配置文件通过ConfigMap挂载，但由于本身ConfigMap的延迟，在用户体验上来说，并不是一种很好的解决方案。更好的做法是通过内核提供的API接口完成Acl配置的更新。\n\n### 使用 Sidecar 来监听本地配置文件变更\n\n这也是业内比较标准的做法。Prometheus 的 Helm Chart 中使用的就是这种方式。这里有一个很实用的镜像叫做 [configmap-reload](https://github.com/jimmidyson/configmap-reload)，它会去 watch 本地文件的变更，并在发生变更时通过 HTTP 调用通知应用进行热更新。同时Emqx Operator对于插件的加载也使用了这种方式。[emqx-operator](https://github.com/emqx/emqx-operator/blob/main/sidecar/reloader/main.go)\n\n\n\n## Reference\n[ConfigMaps | Kubernetes](https://kubernetes.io/docs/concepts/configuration/configmap/)\n\n[Kubernetes Pod 中的 ConfigMap 配置更新 (aleiwu.com)](https://aleiwu.com/post/configmap-hotreload/#热更新二-使用-sidecar-来监听本地配置文件变更)","slug":"configmap","published":1,"updated":"2022-10-16T04:35:27.637Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9axa88j0003m1rg9qaw022t","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>工作中遇到部分组件，它们依赖的一些配置需要通过ConfigMap挂载到容器内部，但ConfigMap自动更新存在一定延时，这可能会带来一系列的问题。在不能滚动重建的前提下，会存在例如配置刷新不及时等问题，如果本身组件不支持热加载的话，就需要通过一些自定义任务去做这些事。</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><h3 id=\"Kubelet\"><a href=\"#Kubelet\" class=\"headerlink\" title=\"Kubelet\"></a>Kubelet</h3><p>Kubelet在每个Node节点都会安装，负责维护该节点上的所有容器，并监视容器的健康状态。同步容器需要的数据，数据可能来自配置文件，也可能来自Etcd。Kubelet通过启动参数–sync-frequency来控制同步的间隔时间。它的默认值是1min，所以更新ConfigMap的内容后，真正容器中的挂载内容变化可能在<code>0~1min</code>之后。</p>\n<p><img src=\"/images/cm.png\" alt=\"indexFile-2\"></p>\n<p>在K8s的官方文档中，说明了ConfigMap 既可以通过 Watch 操作实现内容传播（默认形式），也可实现基于 TTL 的缓存，还可以直接经过所有请求重定向到 API 服务器。 因此，从 ConfigMap 被更新的那一刻算起，到新的主键被投射到 Pod 中去，这一时间跨度可能与 Kubelet 的同步周期加上高速缓存的传播延迟相等。 这里的传播延迟取决于所选的高速缓存类型，分别对应 Watch 操作的传播延迟、高速缓存的 TTL 时长或者 0。</p>\n<p>基于此总延迟时间：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">TotalDelayTime</span> = kubelet sync-frequency + watch manager delay</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><h3 id=\"应用本身监听本地配置文件\"><a href=\"#应用本身监听本地配置文件\" class=\"headerlink\" title=\"应用本身监听本地配置文件\"></a>应用本身监听本地配置文件</h3><p>在RocketMQ中，Acl的更新就通过内核监听配置文件从而实现了热更新。在RocketMQ On K8s中，一种比较常见的做法是，将Acl的配置文件通过ConfigMap挂载，但由于本身ConfigMap的延迟，在用户体验上来说，并不是一种很好的解决方案。更好的做法是通过内核提供的API接口完成Acl配置的更新。</p>\n<h3 id=\"使用-Sidecar-来监听本地配置文件变更\"><a href=\"#使用-Sidecar-来监听本地配置文件变更\" class=\"headerlink\" title=\"使用 Sidecar 来监听本地配置文件变更\"></a>使用 Sidecar 来监听本地配置文件变更</h3><p>这也是业内比较标准的做法。Prometheus 的 Helm Chart 中使用的就是这种方式。这里有一个很实用的镜像叫做 <a href=\"https://github.com/jimmidyson/configmap-reload\">configmap-reload</a>，它会去 watch 本地文件的变更，并在发生变更时通过 HTTP 调用通知应用进行热更新。同时Emqx Operator对于插件的加载也使用了这种方式。<a href=\"https://github.com/emqx/emqx-operator/blob/main/sidecar/reloader/main.go\">emqx-operator</a></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://kubernetes.io/docs/concepts/configuration/configmap/\">ConfigMaps | Kubernetes</a></p>\n<p><a href=\"https://aleiwu.com/post/configmap-hotreload/#%E7%83%AD%E6%9B%B4%E6%96%B0%E4%BA%8C-%E4%BD%BF%E7%94%A8-sidecar-%E6%9D%A5%E7%9B%91%E5%90%AC%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8F%98%E6%9B%B4\">Kubernetes Pod 中的 ConfigMap 配置更新 (aleiwu.com)</a></p>\n","site":{"data":{"footer":"<script color=\"0,0,255\" opacity=\"0.5\" zIndex=\"-1\" count=\"99\" src=\"https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js\"></script>\n"}},"length":949,"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>工作中遇到部分组件，它们依赖的一些配置需要通过ConfigMap挂载到容器内部，但ConfigMap自动更新存在一定延时，这可能会带来一系列的问题。在不能滚动重建的前提下，会存在例如配置刷新不及时等问题，如果本身组件不支持热加载的话，就需要通过一些自定义任务去做这些事。</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><h3 id=\"Kubelet\"><a href=\"#Kubelet\" class=\"headerlink\" title=\"Kubelet\"></a>Kubelet</h3><p>Kubelet在每个Node节点都会安装，负责维护该节点上的所有容器，并监视容器的健康状态。同步容器需要的数据，数据可能来自配置文件，也可能来自Etcd。Kubelet通过启动参数–sync-frequency来控制同步的间隔时间。它的默认值是1min，所以更新ConfigMap的内容后，真正容器中的挂载内容变化可能在<code>0~1min</code>之后。</p>\n<p><img src=\"/images/cm.png\" alt=\"indexFile-2\"></p>\n<p>在K8s的官方文档中，说明了ConfigMap 既可以通过 Watch 操作实现内容传播（默认形式），也可实现基于 TTL 的缓存，还可以直接经过所有请求重定向到 API 服务器。 因此，从 ConfigMap 被更新的那一刻算起，到新的主键被投射到 Pod 中去，这一时间跨度可能与 Kubelet 的同步周期加上高速缓存的传播延迟相等。 这里的传播延迟取决于所选的高速缓存类型，分别对应 Watch 操作的传播延迟、高速缓存的 TTL 时长或者 0。</p>\n<p>基于此总延迟时间：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">TotalDelayTime</span> = kubelet sync-frequency + watch manager delay</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><h3 id=\"应用本身监听本地配置文件\"><a href=\"#应用本身监听本地配置文件\" class=\"headerlink\" title=\"应用本身监听本地配置文件\"></a>应用本身监听本地配置文件</h3><p>在RocketMQ中，Acl的更新就通过内核监听配置文件从而实现了热更新。在RocketMQ On K8s中，一种比较常见的做法是，将Acl的配置文件通过ConfigMap挂载，但由于本身ConfigMap的延迟，在用户体验上来说，并不是一种很好的解决方案。更好的做法是通过内核提供的API接口完成Acl配置的更新。</p>\n<h3 id=\"使用-Sidecar-来监听本地配置文件变更\"><a href=\"#使用-Sidecar-来监听本地配置文件变更\" class=\"headerlink\" title=\"使用 Sidecar 来监听本地配置文件变更\"></a>使用 Sidecar 来监听本地配置文件变更</h3><p>这也是业内比较标准的做法。Prometheus 的 Helm Chart 中使用的就是这种方式。这里有一个很实用的镜像叫做 <a href=\"https://github.com/jimmidyson/configmap-reload\">configmap-reload</a>，它会去 watch 本地文件的变更，并在发生变更时通过 HTTP 调用通知应用进行热更新。同时Emqx Operator对于插件的加载也使用了这种方式。<a href=\"https://github.com/emqx/emqx-operator/blob/main/sidecar/reloader/main.go\">emqx-operator</a></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://kubernetes.io/docs/concepts/configuration/configmap/\">ConfigMaps | Kubernetes</a></p>\n<p><a href=\"https://aleiwu.com/post/configmap-hotreload/#%E7%83%AD%E6%9B%B4%E6%96%B0%E4%BA%8C-%E4%BD%BF%E7%94%A8-sidecar-%E6%9D%A5%E7%9B%91%E5%90%AC%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8F%98%E6%9B%B4\">Kubernetes Pod 中的 ConfigMap 配置更新 (aleiwu.com)</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl9axa88g0001m1rggo0zbm0r","category_id":"cl9axa88k0004m1rge5tc4veb","_id":"cl9axa88m000bm1rghljsay0d"},{"post_id":"cl9axa88j0003m1rg9qaw022t","category_id":"cl9axa88l0008m1rg83g14kkx","_id":"cl9axa88m000dm1rg9wjbf6mp"}],"PostTag":[{"post_id":"cl9axa88g0001m1rggo0zbm0r","tag_id":"cl9axa88k0005m1rg67wveu06","_id":"cl9axa88m000am1rg0a7yetup"},{"post_id":"cl9axa88j0003m1rg9qaw022t","tag_id":"cl9axa88m0009m1rgc5t9e4n6","_id":"cl9axa88m000cm1rg4zwjh5ts"}],"Tag":[{"name":"RocketMQ","_id":"cl9axa88k0005m1rg67wveu06"},{"name":"Kubernetes","_id":"cl9axa88m0009m1rgc5t9e4n6"}]}}